# Part 3: Designing Robust Systems

# Chapter 3.1: Interfaces - The Universal Plug

## Introduction: The Power of Standardization

Think about electrical outlets in your home. In the US, they follow a specific standard shape and voltage. This standardization allows you to plug in any device - a phone charger, a laptop, a lamp - as long as it has the right plug. The outlet doesn't care what the device does; it just provides a standard way to connect.

**Interfaces** in software are exactly like this. They define a **contract** - a set of methods that a class must implement - without specifying how those methods should work.

## What Are Interfaces?

An **interface** is a blueprint for a class. It specifies **what** a class can do (methods) but not **how** it does it (implementation). Classes that implement an interface promise to provide implementations for all its methods.

### Why Do We Need Interfaces?

Imagine you're building a payment system that needs to work with different payment methods:

```pseudo
# WITHOUT Interfaces - Messy and Inflexible

# Each payment method has different methods
CLASS CreditCard:
    METHOD process_credit_card_payment(amount, card_number, expiry):
        # Credit card specific logic
        PRINT "Processing credit card payment"

CLASS PayPal:
    METHOD process_paypal_payment(amount, email):
        # PayPal specific logic
        PRINT "Processing PayPal payment"

CLASS Bitcoin:
    METHOD process_bitcoin_transaction(amount, wallet_address):
        # Bitcoin specific logic
        PRINT "Processing Bitcoin payment"

# The checkout system needs to know about EVERY payment type
CLASS CheckoutSystem:
    METHOD checkout(payment_type, amount, ...details):
        IF payment_type == "credit_card":
            processor = NEW CreditCard()
            processor.process_credit_card_payment(amount, details.card_number, details.expiry)
        ELSE IF payment_type == "paypal":
            processor = NEW PayPal()
            processor.process_paypal_payment(amount, details.email)
        ELSE IF payment_type == "bitcoin":
            processor = NEW Bitcoin()
            processor.process_bitcoin_transaction(amount, details.wallet)
        # What if we add Apple Pay? Google Pay? More IF statements!
```

**Problems:**

1. CheckoutSystem needs to know about every payment type
2. Adding new payment types requires modifying CheckoutSystem
3. Lots of conditional logic
4. No standardization

```pseudo
# WITH Interfaces - Clean and Flexible

# Define an interface - the "universal payment plug"
INTERFACE PaymentProcessor:
    METHOD process_payment(amount)  # No implementation, just signature

# Different classes implement the SAME interface
CLASS CreditCard IMPLEMENTS PaymentProcessor:
    PRIVATE card_number
    PRIVATE expiry

    METHOD process_payment(amount):
        # Credit card specific implementation
        PRINT "Charging $" + amount + " to credit card " + card_number
        # Contact bank, verify, process charge
        RETURN "Credit card payment successful"

CLASS PayPal IMPLEMENTS PaymentProcessor:
    PRIVATE email

    METHOD process_payment(amount):
        # PayPal specific implementation
        PRINT "Processing $" + amount + " via PayPal account " + email
        # Redirect to PayPal, authenticate, process
        RETURN "PayPal payment successful"

CLASS Bitcoin IMPLEMENTS PaymentProcessor:
    PRIVATE wallet_address

    METHOD process_payment(amount):
        # Bitcoin specific implementation
        PRINT "Transferring " + amount + " BTC to wallet " + wallet_address
        # Connect to blockchain, verify, transfer
        RETURN "Bitcoin payment successful"

# CheckoutSystem only knows about the INTERFACE
CLASS CheckoutSystem:
    METHOD checkout(payment_processor: PaymentProcessor, amount):
        # Doesn't care what type of processor it is
        # Just knows it can call process_payment()
        result = payment_processor.process_payment(amount)
        PRINT result
        PRINT "Checkout complete!"

# Usage
checkout = NEW CheckoutSystem()

# Can use ANY payment processor interchangeably
credit_card = NEW CreditCard("1234-5678-9012-3456", "12/25")
checkout.checkout(credit_card, 100.00)  # Works!

paypal = NEW PayPal("user@example.com")
checkout.checkout(paypal, 50.00)  # Also works!

bitcoin = NEW Bitcoin("1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa")
checkout.checkout(bitcoin, 0.05)  # Also works!

# Adding ApplePay is easy!
CLASS ApplePay IMPLEMENTS PaymentProcessor:
    METHOD process_payment(amount):
        PRINT "Processing via Apple Pay"
        RETURN "Apple Pay payment successful"

apple_pay = NEW ApplePay()
checkout.checkout(apple_pay, 75.00)  # Works without changing CheckoutSystem!
```

## Interface Characteristics

### 1. Defines Methods Without Implementation

```pseudo
INTERFACE Drawable:
    METHOD draw()        # No implementation
    METHOD get_area()    # No implementation
    METHOD get_perimeter()  # No implementation
```

### 2. Classes Implement Interfaces

```pseudo
CLASS Circle IMPLEMENTS Drawable:
    PRIVATE radius

    METHOD draw():
        PRINT "Drawing a circle with radius " + radius

    METHOD get_area():
        RETURN 3.14159 * radius * radius

    METHOD get_perimeter():
        RETURN 2 * 3.14159 * radius

CLASS Square IMPLEMENTS Drawable:
    PRIVATE side

    METHOD draw():
        PRINT "Drawing a square with side " + side

    METHOD get_area():
        RETURN side * side

    METHOD get_perimeter():
        RETURN 4 * side
```

### 3. Can Have Multiple Implementations

```pseudo
# A class can implement multiple interfaces
INTERFACE Printable:
    METHOD print()

INTERFACE Scannable:
    METHOD scan()

CLASS AllInOnePrinter IMPLEMENTS Printable, Scannable:
    METHOD print():
        PRINT "Printing document"

    METHOD scan():
        PRINT "Scanning document"
```

## Real-World Interface Examples

### Example 1: Media Player System

```pseudo
# Universal media interface
INTERFACE MediaPlayer:
    METHOD play()
    METHOD pause()
    METHOD stop()
    METHOD get_duration()  # Returns duration in seconds
    METHOD get_current_time()  # Returns current playback time

# Different media types implement the same interface
CLASS AudioPlayer IMPLEMENTS MediaPlayer:
    PRIVATE audio_file
    PRIVATE is_playing
    PRIVATE current_position

    METHOD play():
        IF NOT is_playing:
            is_playing = true
            PRINT "Playing audio: " + audio_file.name
            # Actual audio playing code...

    METHOD pause():
        IF is_playing:
            is_playing = false
            PRINT "Audio paused"

    METHOD stop():
        is_playing = false
        current_position = 0
        PRINT "Audio stopped"

    METHOD get_duration():
        RETURN audio_file.duration

    METHOD get_current_time():
        RETURN current_position

CLASS VideoPlayer IMPLEMENTS MediaPlayer:
    PRIVATE video_file
    PRIVATE is_playing
    PRIVATE current_position
    PRIVATE volume

    METHOD play():
        IF NOT is_playing:
            is_playing = true
            PRINT "Playing video: " + video_file.name
            # Actual video playing code...

    METHOD pause():
        IF is_playing:
            is_playing = false
            PRINT "Video paused"

    # Same interface, different internal handling
    METHOD stop():
        is_playing = false
        current_position = 0
        volume = 0  # Mute on stop
        PRINT "Video stopped and muted"

    METHOD get_duration():
        RETURN video_file.duration

    METHOD get_current_time():
        RETURN current_position

# Streaming player also implements same interface
CLASS StreamingPlayer IMPLEMENTS MediaPlayer:
    PRIVATE stream_url
    PRIVATE is_buffering

    METHOD play():
        IF NOT is_buffering:
            PRINT "Streaming from: " + stream_url
            # Start streaming...

    METHOD pause():
        PRINT "Stream paused (buffering continues)"

    METHOD stop():
        PRINT "Stream stopped and connection closed"

    METHOD get_duration():
        RETURN -1  # Live stream has no fixed duration

    METHOD get_current_time():
        RETURN GET_STREAM_TIME()  # Get from stream server

# Media controller works with ANY MediaPlayer
CLASS MediaController:
    METHOD control_player(player: MediaPlayer):
        PRINT "Controlling media player..."
        player.play()
        WAIT(5)  # Wait 5 seconds
        player.pause()
        WAIT(2)
        player.play()
        WAIT(3)
        player.stop()

        duration = player.get_duration()
        IF duration > 0:
            PRINT "Media duration: " + duration + " seconds"

# Usage
audio = NEW AudioPlayer("song.mp3")
video = NEW VideoPlayer("movie.mp4")
stream = NEW StreamingPlayer("https://livestream.com/channel")

controller = NEW MediaController()

controller.control_player(audio)  # Works with audio
controller.control_player(video)  # Works with video
controller.control_player(stream)  # Works with stream
```

### Example 2: Notification System

```pseudo
# Notification interface
INTERFACE NotificationSender:
    METHOD send_notification(recipient, message)
    METHOD get_status()  # Returns delivery status

# Different notification methods
CLASS EmailSender IMPLEMENTS NotificationSender:
    METHOD send_notification(email_address, message):
        PRINT "Sending email to: " + email_address
        PRINT "Subject: Notification"
        PRINT "Body: " + message
        # Actual email sending code...
        RETURN {"sent": true, "method": "email"}

    METHOD get_status():
        RETURN "Email service connected"

CLASS SMSSender IMPLEMENTS NotificationSender:
    METHOD send_notification(phone_number, message):
        PRINT "Sending SMS to: " + phone_number
        PRINT "Message: " + message
        # Actual SMS sending code...
        RETURN {"sent": true, "method": "sms"}

    METHOD get_status():
        RETURN "SMS gateway active"

CLASS PushNotificationSender IMPLEMENTS NotificationSender:
    METHOD send_notification(device_token, message):
        PRINT "Sending push to device: " + device_token
        PRINT "Alert: " + message
        # Actual push notification code...
        RETURN {"sent": true, "method": "push"}

    METHOD get_status():
        RETURN "Push service connected"

# Notification manager doesn't care about implementation
CLASS NotificationManager:
    PRIVATE senders: List  # List of NotificationSender objects

    METHOD add_sender(sender: NotificationSender):
        ADD sender TO senders

    METHOD notify_all(message):
        PRINT "Sending notification to all channels: " + message
        FOR sender IN senders:
            result = sender.send_notification("default_recipient", message)
            PRINT "Sent via " + result.method + ": " + result.sent

    METHOD broadcast(recipients_by_type, message):
        FOR sender IN senders:
            sender_type = GET_TYPE(sender)  # email, sms, or push
            IF recipients_by_type.CONTAINS_KEY(sender_type):
                recipients = recipients_by_type[sender_type]
                FOR recipient IN recipients:
                    sender.send_notification(recipient, message)

# Usage
manager = NEW NotificationManager()

# Add different senders (all implement same interface)
manager.add_sender(NEW EmailSender())
manager.add_sender(NEW SMSSender())
manager.add_sender(NEW PushNotificationSender())

# Send to all channels
manager.notify_all("Server maintenance at 2 AM tonight")

# Send to specific recipients
recipients = {
    "email": ["admin@company.com", "support@company.com"],
    "sms": ["+1234567890", "+0987654321"],
    "push": ["device_token_abc", "device_token_xyz"]
}

manager.broadcast(recipients, "Urgent: System update required")
```

## Interface Inheritance

Interfaces can extend other interfaces, creating more specialized contracts.

```pseudo
# Base interface
INTERFACE Vehicle:
    METHOD start()
    METHOD stop()
    METHOD get_speed()

# Extended interface - adds more requirements
INTERFACE AdvancedVehicle EXTENDS Vehicle:
    METHOD enable_cruise_control(speed)
    METHOD park_automatically()
    METHOD get_fuel_efficiency()

# Class must implement ALL methods from both interfaces
CLASS SmartCar IMPLEMENTS AdvancedVehicle:
    METHOD start():
        PRINT "Car starting with voice recognition"

    METHOD stop():
        PRINT "Car stopping with automatic brake assist"

    METHOD get_speed():
        RETURN current_speed

    METHOD enable_cruise_control(speed):
        PRINT "Cruise control set to " + speed + " km/h"
        self.target_speed = speed

    METHOD park_automatically():
        PRINT "Searching for parking spot..."
        PRINT "Parking automatically"

    METHOD get_fuel_efficiency():
        RETURN calculate_efficiency()

# Can still be used as basic Vehicle
car = NEW SmartCar()
car.start()  # From Vehicle interface
car.enable_cruise_control(100)  # From AdvancedVehicle interface
```

## Default Methods (Modern Feature)

Some languages allow interfaces to have default implementations.

```pseudo
INTERFILE Logger:
    # Abstract method - must be implemented
    METHOD log_message(message, level)

    # Default method - optional to override
    DEFAULT METHOD log_error(message):
        log_message(message, "ERROR")

    DEFAULT METHOD log_info(message):
        log_message(message, "INFO")

    DEFAULT METHOD get_timestamp():
        RETURN CURRENT_TIMESTAMP()

CLASS FileLogger IMPLEMENTS Logger:
    PRIVATE log_file

    # Must implement abstract method
    METHOD log_message(message, level):
        timestamp = get_timestamp()  # Uses default method
        log_entry = timestamp + " [" + level + "] " + message
        WRITE_TO_FILE(log_file, log_entry)

    # Can override default methods
    METHOD log_error(message):
        log_message("ERROR: " + message, "CRITICAL")  # Different level

# Usage
logger = NEW FileLogger("app.log")
logger.log_info("Application started")  # Uses default log_info
logger.log_error("File not found")      # Uses overridden log_error
```

## Interfaces vs Abstract Classes

| Aspect          | Interface                                 | Abstract Class                              |
| --------------- | ----------------------------------------- | ------------------------------------------- |
| **Methods**     | Only method signatures (usually)          | Can have both abstract and concrete methods |
| **Variables**   | Only constants (usually)                  | Can have any variables                      |
| **Inheritance** | A class can implement multiple interfaces | A class can extend only one abstract class  |
| **Purpose**     | Define capabilities/contracts             | Provide partial implementation              |
| **When to Use** | Unrelated classes need common behavior    | Related classes share common code           |

```pseudo
# Interface example
INTERFACE Flyable:
    METHOD fly()

# Multiple unrelated classes can fly
CLASS Bird IMPLEMENTS Flyable:
    METHOD fly():
        PRINT "Flapping wings"

CLASS Airplane IMPLEMENTS Flyable:
    METHOD fly():
        PRINT "Using jet engines"

CLASS Superhero IMPLEMENTS Flyable:
    METHOD fly():
        PRINT "Using superpowers"

# Abstract class example
ABSTRACT CLASS Animal:
    PRIVATE name
    PRIVATE age

    ABSTRACT METHOD make_sound()

    CONCRETE METHOD eat(food):
        PRINT name + " is eating " + food

    CONCRETE METHOD sleep():
        PRINT name + " is sleeping"

# Related classes extend Animal
CLASS Dog EXTENDS Animal:
    METHOD make_sound():
        PRINT "Woof!"

CLASS Cat EXTENDS Animal:
    METHOD make_sound():
        PRINT "Meow!"
```

## The "Program to Interfaces" Principle

This is a key design principle: **Depend on interfaces, not concrete implementations.**

```pseudo
# BAD: Depends on concrete classes
CLASS DataProcessor:
    METHOD process(data):
        # Directly uses specific database
        db = NEW MySQLDatabase()  # Tight coupling!
        db.connect()
        db.insert(data)
        db.disconnect()

# GOOD: Depends on interface
INTERFACE Database:
    METHOD connect()
    METHOD disconnect()
    METHOD insert(data)
    METHOD query(sql)

CLASS DataProcessor:
    PRIVATE db: Database  # Depends on interface, not implementation

    METHOD INITIALIZE(database: Database):
        db = database  # Can be ANY Database implementation

    METHOD process(data):
        db.connect()
        db.insert(data)
        db.disconnect()

# Now we can use different databases interchangeably
mysql_db = NEW MySQLDatabase()
processor1 = NEW DataProcessor(mysql_db)
processor1.process(some_data)

postgres_db = NEW PostgreSQLDatabase()
processor2 = NEW DataProcessor(postgres_db)  # Same code works!
processor2.process(other_data)

# Even a mock database for testing
mock_db = NEW MockDatabase()
test_processor = NEW DataProcessor(mock_db)
test_processor.process(test_data)
```

## Practical Design Pattern: Strategy Pattern

The Strategy pattern uses interfaces to define a family of algorithms that can be used interchangeably.

```pseudo
# Strategy interface
INTERFACE SortingStrategy:
    METHOD sort(items: List): List

# Different sorting algorithms
CLASS BubbleSort IMPLEMENTS SortingStrategy:
    METHOD sort(items):
        PRINT "Sorting with Bubble Sort"
        # Bubble sort implementation
        RETURN sorted_items

CLASS QuickSort IMPLEMENTS SortingStrategy:
    METHOD sort(items):
        PRINT "Sorting with Quick Sort"
        # Quick sort implementation
        RETURN sorted_items

CLASS MergeSort IMPLEMENTS SortingStrategy:
    METHOD sort(items):
        PRINT "Sorting with Merge Sort"
        # Merge sort implementation
        RETURN sorted_items

# Context class that uses a strategy
CLASS Sorter:
    PRIVATE strategy: SortingStrategy
    PRIVATE items: List

    METHOD INITIALIZE(initial_strategy: SortingStrategy):
        strategy = initial_strategy
        items = []

    METHOD set_strategy(new_strategy: SortingStrategy):
        strategy = new_strategy
        PRINT "Changed sorting strategy to " + GET_TYPE(new_strategy)

    METHOD add_item(item):
        ADD item TO items

    METHOD sort():
        IF LENGTH(items) == 0:
            PRINT "No items to sort"
            RETURN []

        PRINT "Sorting " + LENGTH(items) + " items"
        sorted_items = strategy.sort(items)
        PRINT "Sorting complete"
        RETURN sorted_items

# Usage
sorter = NEW Sorter(NEW BubbleSort())

# Add items
sorter.add_item(5)
sorter.add_item(2)
sorter.add_item(8)
sorter.add_item(1)

# Sort with current strategy (BubbleSort)
result1 = sorter.sort()

# Change strategy at runtime
sorter.set_strategy(NEW QuickSort())
result2 = sorter.sort()

# Change again
sorter.set_strategy(NEW MergeSort())
result3 = sorter.sort()
```

## Interface Segregation Principle

One of the SOLID principles: **Clients should not be forced to depend on interfaces they don't use.**

```pseudo
# BAD: One giant interface
INTERFACE Worker:
    METHOD work()
    METHOD eat()
    METHOD sleep()
    METHOD code()
    METHOD design()
    METHOD test()

# Problem: Not all workers do all things
CLASS Programmer IMPLEMENTS Worker:
    METHOD work(): PRINT "Programming"
    METHOD eat(): PRINT "Eating at desk"
    METHOD sleep(): PRINT "Sleeping"
    METHOD code(): PRINT "Writing code"  # Only programmers code
    METHOD design(): PRINT "Can't design!"  # Forced to implement
    METHOD test(): PRINT "Testing code"

# GOOD: Segregated interfaces
INTERFACE Workable:
    METHOD work()

INTERFACE Eatable:
    METHOD eat()

INTERFACE Sleepable:
    METHOD sleep()

INTERFACE Codeable:
    METHOD code()

INTERFACE Designable:
    METHOD design()

INTERFACE Testable:
    METHOD test()

# Now classes implement only what they need
CLASS Programmer IMPLEMENTS Workable, Eatable, Sleepable, Codeable, Testable:
    METHOD work(): PRINT "Programming"
    METHOD eat(): PRINT "Eating at desk"
    METHOD sleep(): PRINT "Sleeping"
    METHOD code(): PRINT "Writing code"
    METHOD test(): PRINT "Testing code"
    # No design() method needed!

CLASS Designer IMPLEMENTS Workable, Eatable, Sleepable, Designable:
    METHOD work(): PRINT "Designing"
    METHOD eat(): PRINT "Eating at café"
    METHOD sleep(): PRINT "Sleeping"
    METHOD design(): PRINT "Creating designs"
    # No code() or test() methods needed!
```

## Common Interface Patterns

### 1. Factory Pattern with Interfaces

```pseudo
INTERFACE Product:
    METHOD use()

CLASS ConcreteProductA IMPLEMENTS Product:
    METHOD use():
        PRINT "Using Product A"

CLASS ConcreteProductB IMPLEMENTS Product:
    METHOD use():
        PRINT "Using Product B"

INTERFACE ProductFactory:
    METHOD create_product(): Product

CLASS ProductAFactory IMPLEMENTS ProductFactory:
    METHOD create_product():
        RETURN NEW ConcreteProductA()

CLASS ProductBFactory IMPLEMENTS ProductFactory:
    METHOD create_product():
        RETURN NEW ConcreteProductB()

# Usage
factory1 = NEW ProductAFactory()
product1 = factory1.create_product()  # Returns Product A
product1.use()

factory2 = NEW ProductBFactory()
product2 = factory2.create_product()  # Returns Product B
product2.use()
```

### 2. Observer Pattern with Interfaces

```pseudo
INTERFACE Observer:
    METHOD update(data)

INTERFACE Subject:
    METHOD attach(observer: Observer)
    METHOD detach(observer: Observer)
    METHOD notify()

CLASS WeatherStation IMPLEMENTS Subject:
    PRIVATE temperature
    PRIVATE observers: List

    METHOD set_temperature(temp):
        temperature = temp
        notify()  # Notify all observers

    METHOD attach(observer):
        ADD observer TO observers

    METHOD detach(observer):
        REMOVE observer FROM observers

    METHOD notify():
        FOR observer IN observers:
            observer.update(temperature)

CLASS PhoneDisplay IMPLEMENTS Observer:
    METHOD update(temp):
        PRINT "Phone Display: Temperature is " + temp + "°C"

CLASS TVDisplay IMPLEMENTS Observer:
    METHOD update(temp):
        PRINT "TV Display: Current temperature: " + temp + "°C"
```

## Practice Exercise: Shipping System

Design an interface-based shipping system:

1. **Create an interface** `ShippingService` with methods:

   - `calculate_cost(weight, destination)`
   - `estimate_delivery_time(destination)`
   - `ship_package(package_id, destination)`

2. **Implement the interface** for different shipping companies:

   - `FedExShipping`: Uses FedEx API
   - `UPSShipping`: Uses UPS API
   - `DHLShipping`: Uses DHL API

3. **Create a `ShippingCalculator`** class that:

   - Can work with any `ShippingService`
   - Compares costs from different services
   - Recommends the cheapest option

4. **Bonus:** Add a `Trackable` interface with `track_package(tracking_number)` method that only some services implement.

```pseudo
INTERFACE ShippingService:
    METHOD calculate_cost(weight_kg, destination): Float
    METHOD estimate_delivery_time(destination): Integer  # days
    METHOD ship_package(package_id, destination): String  # tracking number

# Your implementations here...

CLASS ShippingCalculator:
    PRIVATE services: List  # List of ShippingService objects

    METHOD add_service(service: ShippingService):
        ADD service TO services

    METHOD compare_costs(weight, destination):
        PRINT "Comparing shipping costs for " + weight + "kg to " + destination
        FOR service IN services:
            cost = service.calculate_cost(weight, destination)
            time = service.estimate_delivery_time(destination)
            PRINT GET_TYPE(service) + ": $" + cost + " (" + time + " days)"

    METHOD find_cheapest(weight, destination):
        cheapest_service = null
        cheapest_cost = INFINITY

        FOR service IN services:
            cost = service.calculate_cost(weight, destination)
            IF cost < cheapest_cost:
                cheapest_cost = cost
                cheapest_service = service

        RETURN {"service": cheapest_service, "cost": cheapest_cost}
```

## Quick Check

1. **What is the main purpose of an interface?**

   - To define a contract that classes must implement

2. **Can an interface contain method implementations?**

   - Traditionally no, but some languages allow default methods

3. **What's the difference between "implements" and "extends"?**

   - "implements" is for interfaces, "extends" is for classes

4. **Why is "program to interfaces" a good practice?**

   - It reduces coupling and makes code more flexible and testable

5. **Can a class implement multiple interfaces?**

   - Yes, most languages allow this

6. **What is the Interface Segregation Principle?**

   - Clients shouldn't be forced to depend on interfaces they don't use

---

**Next Chapter:** [Chapter 3.2: Abstract Classes - The Incomplete Blueprint](./chapter3-2.md) where we'll learn about abstract classes that provide partial implementations!

> **Key Insight:** Interfaces are the ultimate decoupling tool. They allow you to write code that depends on **what objects can do** rather than **what objects are**. This makes your system flexible, extensible, and much easier to maintain. When you design with interfaces, you're building with standard plugs that can accept any compatible device.
