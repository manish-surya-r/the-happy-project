# Chapter 2.1: Attributes & State - Describing Objects

## Introduction: What Makes an Object Unique?

Think about your favorite video game character. What makes them special? Their health points, their level, their special abilities, their appearance. These are all **attributes** - the data that describes an object and its current **state**.

## What Are Attributes?

**Attributes** (also called properties or fields) are the data that an object stores about itself. They represent the **state** of an object at any given moment.

### Real-World Analogy: Your Social Media Profile

Your Instagram profile has:

- **Username**: @yourname (string)
- **Followers**: 1,234 (number)
- **Following**: 567 (number)
- **Posts**: 89 (number)
- **Bio**: "Love coding & coffee" (string)
- **Is Private?**: false (boolean)
- **Profile Picture**: (image data)

Each of these is an attribute that describes the current state of your profile.

## Types of Attributes

### 1. Simple Attributes (Primitive Types)

| Type          | Example            | Description       |
| ------------- | ------------------ | ----------------- |
| **String**    | `name = "Alex"`    | Text data         |
| **Integer**   | `age = 15`         | Whole numbers     |
| **Float**     | `height = 5.8`     | Decimal numbers   |
| **Boolean**   | `is_online = true` | True/False values |
| **Character** | `grade = 'A'`      | Single character  |

### 2. Complex Attributes (Reference Types)

| Type                 | Example                                  | Description                 |
| -------------------- | ---------------------------------------- | --------------------------- |
| **Array/List**       | `subjects = ["Math", "Science"]`         | Collection of values        |
| **Object Reference** | `best_friend = student_object`           | Reference to another object |
| **Dictionary/Map**   | `grades = {"Math": "A", "Science": "B"}` | Key-value pairs             |

## Attribute Visibility: Public vs Private

Remember encapsulation? Attributes should usually be **private** (accessible only within the class) with **public getter/setter methods** to control access.

```pseudo
# BAD: Public attributes (anyone can modify)
CLASS BankAccount:
    PUBLIC balance  # Dangerous!

# Usage:
account = NEW BankAccount()
account.balance = 1000000  # Anyone can set any value!

# GOOD: Private attributes with controlled access
CLASS BankAccount:
    PRIVATE balance
    PRIVATE account_number

    # Getter (read access)
    PUBLIC METHOD get_balance():
        RETURN balance

    # Setter (controlled write access)
    PUBLIC METHOD deposit(amount):
        IF amount > 0:
            balance = balance + amount
        ELSE:
            PRINT "Invalid amount!"

    PUBLIC METHOD withdraw(amount):
        IF amount > 0 AND amount <= balance:
            balance = balance - amount
            RETURN amount
        ELSE:
            PRINT "Invalid withdrawal!"
            RETURN 0
```

## State: The Current Condition of an Object

**State** is the combination of all attribute values at a specific moment. When attributes change, the object's state changes.

### Example: A Traffic Light

```pseudo
CLASS TrafficLight:
    PRIVATE color          # "red", "yellow", "green"
    PRIVATE timer          # seconds remaining
    PRIVATE is_functioning # true/false

    METHOD change_state():
        IF color == "red":
            color = "green"
            timer = 30
        ELSE IF color == "green":
            color = "yellow"
            timer = 5
        ELSE IF color == "yellow":
            color = "red"
            timer = 60

    METHOD get_state():
        RETURN "Color: " + color + ", Time: " + timer + "s, Working: " + is_functioning
```

## Practical Examples

### Example 1: E-commerce Product

```pseudo
CLASS Product:
    # Attributes with data types
    PRIVATE product_id: String
    PRIVATE name: String
    PRIVATE price: Float
    PRIVATE quantity_in_stock: Integer
    PRIVATE is_available: Boolean
    PRIVATE categories: List  # ["Electronics", "Gadgets"]
    PRIVATE ratings: List     # [4.5, 5.0, 3.8]

    # State-changing methods
    METHOD update_price(new_price):
        IF new_price > 0:
            price = new_price
            PRINT "Price updated to $" + new_price

    METHOD reduce_stock(amount):
        IF amount <= quantity_in_stock:
            quantity_in_stock = quantity_in_stock - amount
            IF quantity_in_stock == 0:
                is_available = false
        ELSE:
            PRINT "Insufficient stock!"

    METHOD add_rating(rating):
        ADD rating TO ratings
        PRINT "New rating added: " + rating

    # State query methods
    METHOD is_out_of_stock():
        RETURN quantity_in_stock == 0

    METHOD get_average_rating():
        IF ratings IS EMPTY:
            RETURN 0
        total = 0
        FOR rating IN ratings:
            total = total + rating
        RETURN total / LENGTH(ratings)
```

### Example 2: Game Character with Complex State

```pseudo
CLASS GameCharacter:
    # Basic attributes
    PRIVATE name: String
    PRIVATE level: Integer
    PRIVATE health: Integer
    PRIVATE mana: Integer
    PRIVATE experience: Integer

    # Complex attributes
    PRIVATE inventory: Map  # {"sword": 1, "potion": 3}
    PRIVATE skills: List    # ["fireball", "heal", "shield"]
    PRIVATE position: Map   # {"x": 100, "y": 50, "zone": "forest"}
    PRIVATE status_effects: List  # ["poisoned", "slowed"]

    # Derived attributes (calculated from others)
    METHOD get_max_health():
        RETURN 100 + (level * 10)

    METHOD get_max_mana():
        RETURN 50 + (level * 5)

    # State checking methods
    METHOD is_alive():
        RETURN health > 0

    METHOD is_full_health():
        RETURN health == get_max_health()

    METHOD has_item(item_name):
        RETURN inventory.CONTAINS_KEY(item_name) AND inventory[item_name] > 0

    # State transition methods
    METHOD take_damage(amount):
        health = health - amount
        IF health <= 0:
            health = 0
            PRINT name + " has been defeated!"
            status_effects = []  # Clear all effects on death

    METHOD gain_experience(xp):
        experience = experience + xp
        # Level up check
        required_xp = level * 100
        IF experience >= required_xp:
            level = level + 1
            experience = experience - required_xp
            health = get_max_health()  # Full heal on level up
            mana = get_max_mana()
            PRINT name + " leveled up to " + level + "!"

    METHOD use_item(item_name):
        IF has_item(item_name):
            inventory[item_name] = inventory[item_name] - 1

            # Different items affect state differently
            IF item_name == "health_potion":
                health = MIN(health + 50, get_max_health())
            ELSE IF item_name == "mana_potion":
                mana = MIN(mana + 30, get_max_mana())
            ELSE IF item_name == "antidote":
                REMOVE "poisoned" FROM status_effects
```

## Initial State: Constructors

Objects need to start with some initial state. That's what **constructors** are for (we'll cover them in detail in Chapter 2.3).

```pseudo
CLASS Student:
    PRIVATE name
    PRIVATE age
    PRIVATE grades: List

    # Constructor - sets initial state
    METHOD INITIALIZE(student_name, student_age):
        name = student_name
        age = student_age
        grades = []  # Empty list initially
        PRINT "New student created: " + name

# Creating objects with initial state
alex = NEW Student("Alex Johnson", 15)
# Initial state: name="Alex Johnson", age=15, grades=[]
```

## State Diagram: Visualizing Object State

Let's track how a `ShoppingCart` object's state changes:

```pseudo
CLASS ShoppingCart:
    PRIVATE items: List      # List of Product objects
    PRIVATE total: Float
    PRIVATE is_checked_out: Boolean

    METHOD INITIALIZE():
        items = []
        total = 0.0
        is_checked_out = false

    METHOD add_item(product, quantity):
        IF NOT is_checked_out:
            ADD {"product": product, "quantity": quantity} TO items
            total = total + (product.price * quantity)

    METHOD remove_item(product_id):
        IF NOT is_checked_out:
            # Find and remove item
            # Update total

    METHOD checkout():
        IF NOT is_checked_out AND LENGTH(items) > 0:
            is_checked_out = true
            PRINT "Order placed! Total: $" + total

    METHOD get_state_summary():
        RETURN {
            "item_count": LENGTH(items),
            "total": total,
            "status": IF is_checked_out THEN "Completed" ELSE "Active"
        }
```

**State Transitions:**

```
Initial State:
  items = []
  total = 0.0
  is_checked_out = false

After add_item("Laptop", 1):
  items = [{"product": laptop, "quantity": 1}]
  total = 999.99
  is_checked_out = false

After add_item("Mouse", 2):
  items = [laptop, mouse×2]
  total = 999.99 + (29.99 * 2) = 1059.97
  is_checked_out = false

After checkout():
  items = [laptop, mouse×2]
  total = 1059.97
  is_checked_out = true  # FINAL STATE
```

## Best Practices for Attributes

### 1. Use Meaningful Names

```pseudo
# BAD
CLASS X:
    a: Int
    b: String

# GOOD
CLASS Student:
    grade_level: Integer
    student_id: String
```

### 2. Initialize All Attributes

```pseudo
# BAD - Attributes might be undefined
CLASS Product:
    price  # What's the initial value?

# GOOD - Clear initial state
CLASS Product:
    METHOD INITIALIZE():
        price = 0.0
        name = "Unknown"
        quantity = 0
```

### 3. Group Related Attributes

```pseudo
# Instead of this:
CLASS Player:
    position_x: Float
    position_y: Float
    position_z: Float

# Consider this:
CLASS Player:
    position: Vector3  # Contains x, y, z
    velocity: Vector3
    rotation: Quaternion
```

### 4. Use Constants for Fixed Values

```pseudo
CLASS GameSettings:
    # Constants (usually UPPER_CASE)
    CONST MAX_PLAYERS = 4
    CONST STARTING_HEALTH = 100
    CONST GRAVITY = 9.8

    # Regular attributes
    difficulty: String
    volume: Float
```

## Common Attribute Patterns

### 1. Counter Attributes

```pseudo
CLASS WebsiteVisitor:
    PRIVATE visit_count: Integer
    PRIVATE last_visit: Date

    METHOD visit():
        visit_count = visit_count + 1
        last_visit = CURRENT_DATE()

    METHOD get_visit_stats():
        RETURN {
            "total_visits": visit_count,
            "last_visit": last_visit,
            "is_frequent_visitor": visit_count > 10
        }
```

### 2. Status Flags

```pseudo
CLASS Order:
    PRIVATE is_paid: Boolean
    PRIVATE is_shipped: Boolean
    PRIVATE is_delivered: Boolean
    PRIVATE is_cancelled: Boolean

    METHOD ship_order():
        IF is_paid AND NOT is_cancelled:
            is_shipped = true
            PRINT "Order shipped!"

    METHOD cancel_order():
        IF NOT is_shipped:
            is_cancelled = true
            PRINT "Order cancelled."
```

### 3. Derived Attributes (Calculated on Demand)

```pseudo
CLASS Rectangle:
    PRIVATE width: Float
    PRIVATE height: Float

    # Instead of storing area, calculate it
    METHOD get_area():
        RETURN width * height

    METHOD get_perimeter():
        RETURN 2 * (width + height)

    METHOD is_square():
        RETURN width == height
```

## Practice Exercise: Library Book System

Design a `Book` class with appropriate attributes and state management:

1. **Required Attributes:**

   - `book_id` (String)
   - `title` (String)
   - `author` (String)
   - `isbn` (String)
   - `is_available` (Boolean)
   - `borrower_id` (String or null)
   - `due_date` (Date or null)
   - `condition` (String: "New", "Good", "Worn", "Damaged")

2. **Add Methods to Change State:**

   - `check_out(borrower_id, due_date)`: Updates availability and sets borrower
   - `return_book()`: Marks book as available, clears borrower
   - `update_condition(new_condition)`: Updates book condition
   - `is_overdue()`: Returns true if current date > due_date

3. **Add Validation:**

   - Can't check out an unavailable book
   - Can't return a book that's not checked out
   - Condition can only be specific values

4. **Bonus:** Add `loan_history` attribute that tracks all previous borrowers and dates.

```pseudo
# Starter template
CLASS Book:
    # Define attributes here

    METHOD INITIALIZE(id, title, author, isbn):
        # Set initial state

    METHOD check_out(borrower, due_date):
        # Implement state change

    METHOD return_book():
        # Implement state change

    METHOD get_status():
        # Return current state as readable string
```

## Common Mistakes to Avoid

### 1. Exposing Internal State

```pseudo
# BAD
CLASS User:
    PUBLIC password  # Never do this!

# GOOD
CLASS User:
    PRIVATE password_hash  # Store hash, not plain text
    PUBLIC METHOD verify_password(input):
        RETURN hash(input) == password_hash
```

### 2. Not Validating Attribute Changes

```pseudo
# BAD
CLASS Student:
    METHOD set_grade(new_grade):
        grade = new_grade  # Could be "Z" or 1000!

# GOOD
CLASS Student:
    METHOD set_grade(new_grade):
        VALID_GRADES = ["A", "B", "C", "D", "F"]
        IF new_grade IN VALID_GRADES:
            grade = new_grade
        ELSE:
            PRINT "Invalid grade!"
```

### 3. Storing Redundant Data

```pseudo
# BAD - Storing calculated values that can become inconsistent
CLASS Order:
    subtotal: Float
    tax: Float
    total: Float  # Could become wrong if subtotal changes!

# GOOD - Calculate when needed
CLASS Order:
    subtotal: Float
    tax_rate: Float

    METHOD get_total():
        RETURN subtotal * (1 + tax_rate)
```

## Quick Check

1. **What's the difference between an attribute and a method?**

   - Attributes store data (state), methods perform actions (behavior)

2. **Why should most attributes be private?**

   - To protect data integrity through encapsulation

3. **What is object "state"?**

   - The current values of all an object's attributes at a specific time

4. **Give an example of a derived attribute:**

   - `age` calculated from `birth_date` and current date
   - `full_name` concatenated from `first_name` and `last_name`

---

**Next Chapter:** [Chapter 2.2: Methods &amp; Behavior - What Objects Can Do](./chapter2-2.md) where we'll learn how objects act on their state and interact with other objects!

> **Key Insight:** Attributes define **what an object is**, while methods (next chapter) define **what an object does**. Together, they create complete, useful objects that mirror real-world entities.
