# Chapter 3.2: Abstract Classes - The Incomplete Blueprint

## Introduction: Building on Common Foundations

Imagine you're designing different types of vehicles: cars, motorcycles, trucks, and bicycles. They all share some common characteristics (they have wheels, they can move, they need maintenance) but each has unique features too. An **abstract class** is like a blueprint for a vehicle that defines what all vehicles must have, but leaves the specific details to be filled in by each actual vehicle type.

## What Are Abstract Classes?

An **abstract class** is a class that cannot be instantiated (you can't create objects from it directly). It serves as a base class for other classes and can contain:

1. **Abstract methods** (without implementation) - must be implemented by child classes
2. **Concrete methods** (with implementation) - inherited by child classes
3. **Attributes** (fields) - inherited by child classes
4. **Constructors** - to initialize the base class

### The Analogy: Restaurant Menu Template

Think of a restaurant chain like McDonald's. The corporate office provides:

- **Abstract methods:** "You must have a burger" (but not how to make it)
- **Concrete methods:** "Here's how to clean the kitchen" (same for all locations)
- **Common attributes:** Brand logo, color scheme, uniforms

Each location implements the burger differently (local tastes) but follows the corporate standards.

## Why Use Abstract Classes?

### Problem Without Abstract Classes

```pseudo
# Different shape classes with duplicated code
CLASS Circle:
    PRIVATE radius

    METHOD calculate_area():
        RETURN 3.14159 * radius * radius

    METHOD calculate_perimeter():
        RETURN 2 * 3.14159 * radius

    METHOD draw():
        PRINT "Drawing circle with radius " + radius

CLASS Rectangle:
    PRIVATE width
    PRIVATE height

    METHOD calculate_area():
        RETURN width * height

    METHOD calculate_perimeter():
        RETURN 2 * (width + height)

    METHOD draw():
        PRINT "Drawing rectangle " + width + "×" + height

CLASS Triangle:
    PRIVATE base
    PRIVATE height
    PRIVATE side1
    PRIVATE side2
    PRIVATE side3

    METHOD calculate_area():
        RETURN 0.5 * base * height

    METHOD calculate_perimeter():
        RETURN side1 + side2 + side3

    METHOD draw():
        PRINT "Drawing triangle with base " + base

# Problems:
# 1. Duplicated method names (calculate_area, calculate_perimeter, draw)
# 2. No common type - can't store different shapes in one list
# 3. No enforced consistency
```

### Solution With Abstract Classes

```pseudo
# Abstract base class
ABSTRACT CLASS Shape:
    # Abstract methods - MUST be implemented by child classes
    ABSTRACT METHOD calculate_area()
    ABSTRACT METHOD calculate_perimeter()
    ABSTRACT METHOD draw()

    # Concrete method - provided to ALL child classes
    METHOD get_description():
        RETURN "This is a shape with area: " + calculate_area() +
               " and perimeter: " + calculate_perimeter()

    # Can have attributes
    PRIVATE color
    PRIVATE is_filled

    # Can have constructor
    METHOD INITIALIZE(shape_color, filled):
        color = shape_color
        is_filled = filled

# Concrete child classes
CLASS Circle EXTENDS Shape:
    PRIVATE radius

    METHOD INITIALIZE(circle_color, filled, circle_radius):
        SUPER.INITIALIZE(circle_color, filled)  # Call parent constructor
        radius = circle_radius

    # MUST implement all abstract methods
    METHOD calculate_area():
        RETURN 3.14159 * radius * radius

    METHOD calculate_perimeter():
        RETURN 2 * 3.14159 * radius

    METHOD draw():
        PRINT "Drawing " + color + " circle with radius " + radius
        IF is_filled:
            PRINT "Circle is filled"

CLASS Rectangle EXTENDS Shape:
    PRIVATE width
    PRIVATE height

    METHOD INITIALIZE(rect_color, filled, rect_width, rect_height):
        SUPER.INITIALIZE(rect_color, filled)
        width = rect_width
        height = rect_height

    METHOD calculate_area():
        RETURN width * height

    METHOD calculate_perimeter():
        RETURN 2 * (width + height)

    METHOD draw():
        PRINT "Drawing " + color + " rectangle " + width + "×" + height
        IF is_filled:
            PRINT "Rectangle is filled"

# Now we can use polymorphism
shapes = []
shapes.ADD(NEW Circle("red", true, 5))
shapes.ADD(NEW Rectangle("blue", false, 4, 6))
shapes.ADD(NEW Circle("green", true, 3))

FOR shape IN shapes:
    shape.draw()
    PRINT shape.get_description()  # Uses parent's concrete method
    PRINT "Area: " + shape.calculate_area()  # Uses child's implementation
```

## Key Characteristics of Abstract Classes

### 1. Cannot Be Instantiated

```pseudo
ABSTRACT CLASS Animal:
    ABSTRACT METHOD make_sound()

# This will cause an error:
animal = NEW Animal()  # ERROR: Cannot instantiate abstract class

# But child classes can be instantiated
CLASS Dog EXTENDS Animal:
    METHOD make_sound():
        PRINT "Woof!"

dog = NEW Dog()  # OK
```

### 2. Mix of Abstract and Concrete Methods

```pseudo
ABSTRACT CLASS DatabaseConnection:
    # Abstract method - must be implemented
    ABSTRACT METHOD connect()
    ABSTRACT METHOD disconnect()

    # Concrete method - provided to all children
    METHOD execute_query(sql):
        connect()  # Calls child's implementation
        PRINT "Executing: " + sql
        # Execute query logic...
        disconnect()  # Calls child's implementation

    # Another concrete method
    METHOD get_connection_info():
        RETURN "Database connection details"

CLASS MySQLConnection EXTENDS DatabaseConnection:
    METHOD connect():
        PRINT "Connecting to MySQL database..."

    METHOD disconnect():
        PRINT "Disconnecting from MySQL"

# Usage
mysql = NEW MySQLConnection()
mysql.execute_query("SELECT * FROM users")
# Output:
# "Connecting to MySQL database..."
# "Executing: SELECT * FROM users"
# "Disconnecting from MySQL"
```

### 3. Can Have Constructors

```pseudo
ABSTRACT CLASS Employee:
    PRIVATE name
    PRIVATE id
    PRIVATE base_salary

    METHOD INITIALIZE(emp_name, emp_id, salary):
        name = emp_name
        id = emp_id
        base_salary = salary

    # Abstract method
    ABSTRACT METHOD calculate_bonus()

    # Concrete method using abstract method
    METHOD get_total_compensation():
        RETURN base_salary + calculate_bonus()

CLASS Manager EXTENDS Employee:
    PRIVATE team_size

    METHOD INITIALIZE(mgr_name, mgr_id, salary, team):
        SUPER.INITIALIZE(mgr_name, mgr_id, salary)
        team_size = team

    METHOD calculate_bonus():
        RETURN base_salary * 0.20 + (team_size * 1000)

CLASS Developer EXTENDS Employee:
    PRIVATE programming_languages

    METHOD INITIALIZE(dev_name, dev_id, salary, languages):
        SUPER.INITIALIZE(dev_name, dev_id, salary)
        programming_languages = languages

    METHOD calculate_bonus():
        RETURN base_salary * 0.15 + (LENGTH(programming_languages) * 500)

# Usage
manager = NEW Manager("Alice", "M001", 80000, 5)
developer = NEW Developer("Bob", "D001", 70000, ["Java", "Python", "JavaScript"])

PRINT manager.get_total_compensation()  # Uses parent's concrete method + child's abstract
PRINT developer.get_total_compensation()  # Same parent method, different child implementation
```

## Abstract Classes vs Interfaces

| Aspect            | Abstract Class                         | Interface                                        |
| ----------------- | -------------------------------------- | ------------------------------------------------ |
| **Instantiation** | Cannot be instantiated                 | Cannot be instantiated                           |
| **Methods**       | Can have both abstract and concrete    | Traditionally only abstract (some allow default) |
| **Variables**     | Can have any variables                 | Usually only constants                           |
| **Inheritance**   | Single inheritance (extends one class) | Multiple implementation (implements many)        |
| **Constructors**  | Can have constructors                  | Cannot have constructors                         |
| **When to Use**   | When classes share common code/state   | When classes need common behavior contract       |

### Combined Example: Using Both

```pseudo
# Interface for specific capability
INTERFACE Flyable:
    METHOD fly()

# Abstract base class with common mammal functionality
ABSTRACT CLASS Mammal:
    PRIVATE name
    PRIVATE age

    METHOD INITIALIZE(mammal_name, mammal_age):
        name = mammal_name
        age = mammal_age

    # Concrete methods for all mammals
    METHOD breathe():
        PRINT name + " is breathing air"

    METHOD eat(food):
        PRINT name + " is eating " + food

    # Abstract method - mammals make sounds differently
    ABSTRACT METHOD make_sound()

# Concrete classes
CLASS Dog EXTENDS Mammal:
    METHOD make_sound():
        PRINT name + " says: Woof!"

    METHOD fetch():
        PRINT name + " is fetching the ball"

CLASS Bat EXTENDS Mammal IMPLEMENTS Flyable:
    METHOD make_sound():
        PRINT name + " makes ultrasonic sounds"

    METHOD fly():
        PRINT name + " is flying using wings"

# Usage
dog = NEW Dog("Rex", 3)
dog.breathe()    # From Mammal
dog.eat("bone")  # From Mammal
dog.make_sound() # Dog's implementation
dog.fetch()      # Dog's own method

bat = NEW Bat("Batty", 1)
bat.breathe()    # From Mammal
bat.fly()        # From Flyable interface
bat.make_sound() # Bat's implementation
```

## Real-World Examples

### Example 1: Document Processing System

```pseudo
ABSTRACT CLASS Document:
    PRIVATE title
    PRIVATE author
    PRIVATE content
    PRIVATE created_date
    PRIVATE modified_date

    METHOD INITIALIZE(doc_title, doc_author, doc_content):
        title = doc_title
        author = doc_author
        content = doc_content
        created_date = CURRENT_DATE()
        modified_date = created_date

    # Concrete methods for all documents
    METHOD get_metadata():
        RETURN {
            "title": title,
            "author": author,
            "created": created_date,
            "modified": modified_date,
            "word_count": count_words(),
            "type": get_document_type()
        }

    METHOD count_words():
        words = SPLIT(content, " ")
        RETURN LENGTH(words)

    METHOD update_content(new_content):
        content = new_content
        modified_date = CURRENT_DATE()
        PRINT "Document updated"

    # Abstract methods - different for each document type
    ABSTRACT METHOD save()          # How to save differs
    ABSTRACT METHOD print_format()  # Print format differs
    ABSTRACT METHOD get_document_type()  # Returns type name

    # Template method pattern - uses abstract methods
    METHOD process_and_save():
        PRINT "Processing " + get_document_type() + " document..."
        validate_content()
        format_for_save()
        save()
        PRINT "Document saved successfully"

    # More abstract methods used in template
    ABSTRACT METHOD validate_content()
    ABSTRACT METHOD format_for_save()

# Concrete document types
CLASS PDFDocument EXTENDS Document:
    METHOD save():
        PRINT "Saving as PDF file with compression"
        # PDF-specific saving logic

    METHOD print_format():
        PRINT "Formatting for PDF printing (A4 size, margins)"
        # PDF printing logic

    METHOD get_document_type():
        RETURN "PDF"

    METHOD validate_content():
        PRINT "Validating PDF content structure..."
        # PDF-specific validation

    METHOD format_for_save():
        PRINT "Formatting for PDF export..."
        # PDF-specific formatting

CLASS WordDocument EXTENDS Document:
    PRIVATE template

    METHOD save():
        PRINT "Saving as .docx file with Office Open XML format"
        # Word-specific saving logic

    METHOD print_format():
        PRINT "Formatting for Word printing (letter size, headers/footers)"
        # Word printing logic

    METHOD get_document_type():
        RETURN "Microsoft Word"

    METHOD validate_content():
        PRINT "Validating Word document compatibility..."
        # Word-specific validation

    METHOD format_for_save():
        PRINT "Applying Word template: " + template
        # Word-specific formatting

CLASS PlainTextDocument EXTENDS Document:
    METHOD save():
        PRINT "Saving as plain text (.txt) file with UTF-8 encoding"
        # Text file saving logic

    METHOD print_format():
        PRINT "Formatting for text printing (monospace font, 80 columns)"
        # Text printing logic

    METHOD get_document_type():
        RETURN "Plain Text"

    METHOD validate_content():
        PRINT "Validating text encoding..."
        # Text-specific validation

    METHOD format_for_save():
        PRINT "Formatting text with line breaks..."
        # Text-specific formatting

# Usage
documents = []
documents.ADD(NEW PDFDocument("Report", "Alice", "This is a PDF report..."))
documents.ADD(NEW WordDocument("Essay", "Bob", "This is a Word essay..."))
documents.ADD(NEW PlainTextDocument("Notes", "Charlie", "These are plain text notes..."))

FOR doc IN documents:
    PRINT "=== Processing Document ==="
    PRINT doc.get_metadata()
    doc.process_and_save()  # Template method uses child implementations
    PRINT ""
```

### Example 2: Game Character System

```pseudo
ABSTRACT CLASS GameCharacter:
    PRIVATE name
    PRIVATE level
    PRIVATE health
    PRIVATE mana
    PRIVATE experience

    METHOD INITIALIZE(char_name, start_level = 1):
        name = char_name
        level = start_level
        health = calculate_max_health()
        mana = calculate_max_mana()
        experience = 0

    # Concrete methods for all characters
    METHOD is_alive():
        RETURN health > 0

    METHOD take_damage(amount):
        health = health - amount
        IF health <= 0:
            health = 0
            PRINT name + " has been defeated!"

    METHOD heal(amount):
        max_hp = calculate_max_health()
        health = MIN(health + amount, max_hp)
        PRINT name + " healed " + amount + " HP"

    METHOD gain_experience(xp):
        experience = experience + xp
        WHILE experience >= get_experience_for_next_level():
            level_up()

    METHOD level_up():
        level = level + 1
        experience = experience - get_experience_for_next_level()
        health = calculate_max_health()  # Full heal on level up
        mana = calculate_max_mana()
        PRINT name + " leveled up to level " + level + "!"
        # Call abstract method for class-specific level up logic
        on_level_up()

    # Abstract methods - different for each character class
    ABSTRACT METHOD calculate_max_health()
    ABSTRACT METHOD calculate_max_mana()
    ABSTRACT METHOD get_experience_for_next_level()
    ABSTRACT METHOD attack(target)
    ABSTRACT METHOD defend()
    ABSTRACT METHOD use_special_ability()
    ABSTRACT METHOD on_level_up()  # Called when leveling up

    # Template method for combat turn
    METHOD take_turn(target):
        IF NOT is_alive():
            PRINT name + " is defeated and cannot act"
            RETURN

        PRINT name + "'s turn (Level " + level + ")"
        PRINT "HP: " + health + "/" + calculate_max_health()
        PRINT "Mana: " + mana + "/" + calculate_max_mana()

        # Decision logic (simplified)
        IF health < calculate_max_health() * 0.3:
            defend()  # Abstract method
        ELSE IF mana >= 20:
            use_special_ability()  # Abstract method
        ELSE:
            attack(target)  # Abstract method

# Concrete character classes
CLASS Warrior EXTENDS GameCharacter:
    PRIVATE strength
    PRIVATE defense

    METHOD INITIALIZE(warrior_name, start_level):
        SUPER.INITIALIZE(warrior_name, start_level)
        strength = 10 + (level * 2)
        defense = 8 + (level * 1.5)

    METHOD calculate_max_health():
        RETURN 100 + (level * 20) + (strength * 5)

    METHOD calculate_max_mana():
        RETURN 30 + (level * 5)  # Warriors have low mana

    METHOD get_experience_for_next_level():
        RETURN level * 100

    METHOD attack(target):
        damage = strength * 2
        PRINT name + " swings sword for " + damage + " damage!"
        target.take_damage(damage)

    METHOD defend():
        defense = defense * 1.5  # Temporary boost
        PRINT name + " raises shield! Defense increased"

    METHOD use_special_ability():
        IF mana >= 20:
            mana = mana - 20
            damage = strength * 4
            PRINT name + " uses WHIRLWIND ATTACK for " + damage + " damage!"
            # Would hit multiple targets in real game
        ELSE:
            PRINT "Not enough mana!"

    METHOD on_level_up():
        strength = strength + 3
        defense = defense + 2
        PRINT name + " gained strength and defense!"

CLASS Mage EXTENDS GameCharacter:
    PRIVATE intelligence
    PRIVATE spellbook: List

    METHOD INITIALIZE(mage_name, start_level):
        SUPER.INITIALIZE(mage_name, start_level)
        intelligence = 15 + (level * 3)
        spellbook = ["Fireball", "Ice Shard", "Lightning Bolt"]

    METHOD calculate_max_health():
        RETURN 60 + (level * 10)  # Mages have low health

    METHOD calculate_max_mana():
        RETURN 100 + (level * 20) + (intelligence * 3)

    METHOD get_experience_for_next_level():
        RETURN level * 120  # Mages need more XP

    METHOD attack(target):
        damage = intelligence
        PRINT name + " casts a basic spell for " + damage + " damage!"
        target.take_damage(damage)

    METHOD defend():
        PRINT name + " casts a magical barrier!"
        # Would add damage reduction in real game

    METHOD use_special_ability():
        IF mana >= 30:
            mana = mana - 30
            damage = intelligence * 3
            PRINT name + " casts FIREBALL for " + damage + " damage!"
            # Would be area damage in real game
        ELSE:
            PRINT "Not enough mana!"

    METHOD on_level_up():
        intelligence = intelligence + 5
        IF level % 3 == 0:  # Every 3 levels
            new_spell = "Spell Level " + level
            ADD new_spell TO spellbook
            PRINT name + " learned new spell: " + new_spell

CLASS Archer EXTENDS GameCharacter:
    PRIVATE agility
    PRIVATE arrows

    METHOD INITIALIZE(archer_name, start_level):
        SUPER.INITIALIZE(archer_name, start_level)
        agility = 12 + (level * 2)
        arrows = 20 + (level * 5)

    METHOD calculate_max_health():
        RETURN 80 + (level * 15)

    METHOD calculate_max_mana():
        RETURN 50 + (level * 10)

    METHOD get_experience_for_next_level():
        RETURN level * 90

    METHOD attack(target):
        IF arrows > 0:
            arrows = arrows - 1
            damage = agility * 1.5
            PRINT name + " shoots arrow for " + damage + " damage!"
            PRINT "Arrows remaining: " + arrows
            target.take_damage(damage)
        ELSE:
            PRINT name + " is out of arrows!"

    METHOD defend():
        PRINT name + " dodges nimbly!"
        # Would increase dodge chance in real game

    METHOD use_special_ability():
        IF mana >= 25:
            mana = mana - 25
            IF arrows >= 3:
                arrows = arrows - 3
                damage = agility * 2 * 3
                PRINT name + " uses MULTISHOT for " + damage + " damage!"
                PRINT "Used 3 arrows"
            ELSE:
                PRINT "Not enough arrows for multishot!"
        ELSE:
            PRINT "Not enough mana!"

    METHOD on_level_up():
        agility = agility + 4
        arrows = arrows + 10
        PRINT name + " became more agile and got more arrows!"

# Game simulation
warrior = NEW Warrior("Aragorn", 5)
mage = NEW Mage("Gandalf", 5)
archer = NEW Archer("Legolas", 5)

monster = NEW Warrior("Orc", 3)
monster.health = 50  # Weaken monster for demo

PRINT "=== BATTLE BEGINS ==="

# Characters take turns (template method pattern)
characters = [warrior, mage, archer]
turn = 1

WHILE monster.is_alive() AND ANY character.is_alive() FOR character IN characters:
    PRINT "\n=== Turn " + turn + " ==="

    FOR character IN characters:
        IF character.is_alive():
            character.take_turn(monster)  # Template method calls abstract methods

    IF monster.is_alive():
        # Monster attacks random character
        alive_characters = FILTER characters WHERE character.is_alive()
        IF LENGTH(alive_characters) > 0:
            target = RANDOM_FROM(alive_characters)
            monster.attack(target)

    turn = turn + 1

PRINT "\n=== BATTLE ENDED ==="
IF monster.is_alive():
    PRINT "Monster won!"
ELSE:
    PRINT "Heroes won!"
    # Award experience
    FOR character IN characters:
        IF character.is_alive():
            character.gain_experience(100)
```

## The Template Method Pattern

Abstract classes are perfect for implementing the **Template Method Pattern**, where you define the skeleton of an algorithm in the base class and let subclasses override specific steps.

```pseudo
ABSTRACT CLASS DataProcessor:
    # Template method - defines algorithm skeleton
    METHOD process_data(raw_data):
        PRINT "Starting data processing..."

        validated_data = validate(raw_data)  # Abstract step
        cleaned_data = clean(validated_data)  # Abstract step
        transformed_data = transform(cleaned_data)  # Abstract step

        result = save(transformed_data)  # Concrete step
        log_processing(result)  # Concrete step

        RETURN result

    # Abstract steps - to be implemented by subclasses
    ABSTRACT METHOD validate(data)
    ABSTRACT METHOD clean(data)
    ABSTRACT METHOD transform(data)

    # Concrete steps - common to all processors
    METHOD save(data):
        PRINT "Saving processed data..."
        # Common saving logic
        RETURN {"success": true, "records": LENGTH(data)}

    METHOD log_processing(result):
        PRINT "Processing completed: " + result.success
        PRINT "Records processed: " + result.records

CLASS CSVProcessor EXTENDS DataProcessor:
    METHOD validate(data):
        PRINT "Validating CSV format..."
        # CSV-specific validation
        RETURN data

    METHOD clean(data):
        PRINT "Cleaning CSV data (removing nulls, trimming)..."
        # CSV-specific cleaning
        RETURN data

    METHOD transform(data):
        PRINT "Transforming CSV (converting dates, formatting)..."
        # CSV-specific transformation
        RETURN data

CLASS JSONProcessor EXTENDS DataProcessor:
    METHOD validate(data):
        PRINT "Validating JSON structure..."
        # JSON-specific validation
        RETURN data

    METHOD clean(data):
        PRINT "Cleaning JSON (escaping characters, validating types)..."
        # JSON-specific cleaning
        RETURN data

    METHOD transform(data):
        PRINT "Transforming JSON (flattening nested objects)..."
        # JSON-specific transformation
        RETURN data

# Usage
csv_data = "name,age\nAlice,30\nBob,25"
json_data = '{"users": [{"name": "Alice", "age": 30}]}'

csv_processor = NEW CSVProcessor()
csv_result = csv_processor.process_data(csv_data)
# Output shows CSV-specific steps within the template

json_processor = NEW JSONProcessor()
json_result = json_processor.process_data(json_data)
# Output shows JSON-specific steps within the same template
```

## When to Use Abstract Classes

### Use Abstract Classes When:

1. **You have related classes that share common code**

   ```pseudo
   ABSTRACT CLASS Vehicle:
       PRIVATE speed
       METHOD accelerate(amount)  # Common to all vehicles

   CLASS Car EXTENDS Vehicle
   CLASS Bike EXTENDS Vehicle
   ```

2. **You need to provide default implementations**

   ```pseudo
   ABSTRACT CLASS Animal:
       METHOD breathe()  # Default implementation for all animals
           PRINT "Breathing..."

       ABSTRACT METHOD make_sound()  # Each animal sounds different
   ```

3. **You want to control the inheritance hierarchy**

   ```pseudo
   ABSTRACT CLASS Employee:
       # Force all employees to have ID and calculate pay
       ABSTRACT METHOD get_employee_id()
       ABSTRACT METHOD calculate_pay()
   ```

4. **You're implementing the Template Method Pattern**

   ```pseudo
   ABSTRACT CLASS Game:
       METHOD play():  # Template method
           initialize()
           WHILE NOT game_over():
               take_turn()
           display_winner()

       ABSTRACT METHOD initialize()
       ABSTRACT METHOD take_turn()
       ABSTRACT METHOD game_over()
       ABSTRACT METHOD display_winner()
   ```

### Don't Use Abstract Classes When:

1. **You need multiple inheritance** (use interfaces instead)
2. **The classes are unrelated** (use interfaces for common behavior)
3. **You might need to instantiate the base class later** (make it concrete)

## Common Patterns with Abstract Classes

### Pattern 1: Factory Method Pattern

```pseudo
ABSTRACT CLASS Dialog:
    # Factory method - creates product, implementation varies
    ABSTRACT METHOD create_button(): Button

    # Template method using factory method
    METHOD render():
        PRINT "Rendering dialog..."
        button = create_button()  # Calls child's factory method
        button.render()
        PRINT "Dialog rendered"

CLASS WindowsDialog EXTENDS Dialog:
    METHOD create_button():
        RETURN NEW WindowsButton()

CLASS WebDialog EXTENDS Dialog:
    METHOD create_button():
        RETURN NEW HTMLButton()

# Usage
dialog1 = NEW WindowsDialog()
dialog1.render()  # Creates WindowsButton

dialog2 = NEW WebDialog()
dialog2.render()  # Creates HTMLButton
```

### Pattern 2: Chain of Responsibility

```pseudo
ABSTRACT CLASS Handler:
    PRIVATE next_handler

    METHOD set_next(handler):
        next_handler = handler
        RETURN handler  # For fluent chaining

    METHOD handle(request):
        IF can_handle(request):
            process(request)
        ELSE IF next_handler != null:
            next_handler.handle(request)
        ELSE:
            PRINT "No handler available for: " + request

    ABSTRACT METHOD can_handle(request)
    ABSTRACT METHOD process(request)

CLASS SpamHandler EXTENDS Handler:
    METHOD can_handle(request):
        RETURN request CONTAINS "buy now" OR request CONTAINS "cheap"

    METHOD process(request):
        PRINT "SpamHandler: Marked as spam"

CLASS ComplaintHandler EXTENDS Handler:
    METHOD can_handle(request):
        RETURN request CONTAINS "complaint" OR request CONTAINS "refund"

    METHOD process(request):
        PRINT "ComplaintHandler: Forwarded to customer service"
```

## Practice Exercise: Notification System

Create an abstract class for a notification system:

1. **Create an abstract class `Notification`** with:

   - Attributes: `recipient`, `message`, `timestamp`
   - Concrete methods: `get_info()`, `mark_as_sent()`, `is_expired()`
   - Abstract methods: `send()`, `format_message()`, `validate_recipient()`

2. **Create concrete classes** that extend `Notification`:

   - `EmailNotification`: Sends via email
   - `SMSNotification`: Sends via SMS
   - `PushNotification`: Sends push notification

3. **Implement a template method** `process_notification()` in the abstract class that:

   - Validates recipient
   - Formats message
   - Sends notification
   - Marks as sent
   - Returns success status

4. **Add a method to calculate priority** (abstract) that each notification type implements differently.

```pseudo
ABSTRACT CLASS Notification:
    PRIVATE recipient
    PRIVATE message
    PRIVATE timestamp
    PRIVATE is_sent
    PRIVATE sent_time

    METHOD INITIALIZE(notif_recipient, notif_message):
        recipient = notif_recipient
        message = notif_message
        timestamp = CURRENT_TIME()
        is_sent = false
        sent_time = null

    # Template method
    METHOD process_notification():
        PRINT "Processing notification..."

        IF NOT validate_recipient():
            PRINT "Invalid recipient"
            RETURN false

        formatted_message = format_message()
        IF formatted_message == "":
            PRINT "Failed to format message"
            RETURN false

        success = send(formatted_message)
        IF success:
            mark_as_sent()
            PRINT "Notification sent successfully"
        ELSE:
            PRINT "Failed to send notification"

        RETURN success

    # Concrete methods
    METHOD get_info():
        RETURN {
            "recipient": recipient,
            "message": SUBSTRING(message, 0, 50) + "...",
            "timestamp": timestamp,
            "is_sent": is_sent,
            "sent_time": sent_time,
            "priority": calculate_priority()  # Uses abstract method
        }

    METHOD mark_as_sent():
        is_sent = true
        sent_time = CURRENT_TIME()

    METHOD is_expired():
        hours_since_creation = HOURS_DIFFERENCE(CURRENT_TIME(), timestamp)
        RETURN hours_since_creation > 24  # Expires after 24 hours

    # Abstract methods - implement in child classes
    ABSTRACT METHOD send(formatted_message)
    ABSTRACT METHOD format_message()
    ABSTRACT METHOD validate_recipient()
    ABSTRACT METHOD calculate_priority()  # Returns priority level 1-10

# Your implementations here...
```

## Quick Check

1. **Can you create an object from an abstract class?**

   - No, abstract classes cannot be instantiated

2. **What happens if a child class doesn't implement all abstract methods?**

   - The child class must also be declared abstract

3. **Can abstract classes have constructors?**

   - Yes, abstract classes can have constructors

4. **What's the main difference between abstract classes and interfaces?**

   - Abstract classes can have implementation (concrete methods), interfaces traditionally cannot

5. **When should you use an abstract class instead of an interface?**

   - When you have related classes that share common code and state

6. **What design pattern commonly uses abstract classes?**

   - Template Method Pattern

7. **Can a class extend an abstract class and implement an interface?**

   - Yes, e.g., `CLASS MyClass EXTENDS AbstractClass IMPLEMENTS SomeInterface`

---

**Next Chapter:** [Chapter 3.3: Key Design Principles (Made Simple)](./chapter3-3.md) where we'll learn about DRY, Single Responsibility, and other essential design principles!

> **Key Insight:** Abstract classes are the perfect tool when you need to define a common structure and behavior for a family of related classes while allowing customization. They're like a recipe where some steps are fixed ("preheat oven to 350°F") and others are left to the chef ("add your choice of vegetables"). This balance between standardization and flexibility is what makes abstract classes so powerful in object-oriented design.
