# Chapter 3.3: Key Design Principles (Made Simple)

## Introduction: Building Software That Doesn't Break

Imagine you're building a house. You wouldn't:

1. Make all the electrical wiring pass through one single wire (that would burn!)
2. Build the kitchen inside the bathroom (that's messy!)
3. Use different blueprints for every room (that's confusing!)

Software design has similar principles. Today, we'll learn three essential principles that will make your code cleaner, more maintainable, and less prone to errors.

## 1. DRY: Don't Repeat Yourself

### The Problem: WET Code (Write Everything Twice or more!)

**WET Code Example:**

```pseudo
# Student grade calculator - repeating the same logic
CLASS MathStudent:
    METHOD calculate_average(math_grades):
        total = 0
        FOR grade IN math_grades:
            total = total + grade
        average = total / LENGTH(math_grades)
        RETURN average

    METHOD print_report(math_grades):
        average = calculate_average(math_grades)
        PRINT "Math Average: " + average

CLASS ScienceStudent:
    METHOD calculate_average(science_grades):
        total = 0
        FOR grade IN science_grades:
            total = total + grade  # Same logic!
        average = total / LENGTH(science_grades)  # Same logic!
        RETURN average

    METHOD print_report(science_grades):
        average = calculate_average(science_grades)
        PRINT "Science Average: " + average

CLASS EnglishStudent:
    METHOD calculate_average(english_grades):
        total = 0
        FOR grade IN english_grades:
            total = total + grade  # Same logic AGAIN!
        average = total / LENGTH(english_grades)  # Same logic AGAIN!
        RETURN average

    METHOD print_report(english_grades):
        average = calculate_average(english_grades)
        PRINT "English Average: " + average

# Problem: If we need to change the calculation
# (e.g., handle empty lists), we have to change it in 3 places!
```

### The Solution: DRY Principle

**DRY Code Example:**

```pseudo
# Create a reusable utility class
CLASS GradeCalculator:
    # One place for the calculation logic
    STATIC METHOD calculate_average(grades):
        IF LENGTH(grades) == 0:
            RETURN 0
        total = 0
        FOR grade IN grades:
            total = total + grade
        RETURN total / LENGTH(grades)

    STATIC METHOD get_letter_grade(average):
        IF average >= 90: RETURN "A"
        IF average >= 80: RETURN "B"
        IF average >= 70: RETURN "C"
        IF average >= 60: RETURN "D"
        RETURN "F"

# Now students just use the utility
CLASS MathStudent:
    METHOD print_report(math_grades):
        average = GradeCalculator.calculate_average(math_grades)
        letter = GradeCalculator.get_letter_grade(average)
        PRINT "Math: " + average + " (" + letter + ")"

CLASS ScienceStudent:
    METHOD print_report(science_grades):
        average = GradeCalculator.calculate_average(science_grades)
        letter = GradeCalculator.get_letter_grade(average)
        PRINT "Science: " + average + " (" + letter + ")"

CLASS EnglishStudent:
    METHOD print_report(english_grades):
        average = GradeCalculator.calculate_average(english_grades)
        letter = GradeCalculator.get_letter_grade(average)
        PRINT "English: " + average + " (" + letter + ")"

# Now if we need to change the calculation,
# we change it in ONE place only!
```

### Real-World Analogy: School Bell Schedule

**WET School (Bad):**

- Each classroom has its own clock
- Each teacher decides when class starts/ends
- No coordination - chaos!

**DRY School (Good):**

- One central bell system
- All classrooms follow the same schedule
- One place to change if schedule needs adjustment

### When to Apply DRY:

1. **Same logic appears in multiple places**
2. **Constants or configuration values are duplicated**
3. **Similar validation rules exist in different classes**
4. **Database queries are copy-pasted**

### DRY in Action: Configuration Example

```pseudo
# BAD: Hardcoded values everywhere
CLASS EmailService:
    METHOD send_welcome_email():
        smtp_server = "smtp.gmail.com"
        port = 587
        timeout = 30
        # Use these values...

    METHOD send_password_reset():
        smtp_server = "smtp.gmail.com"  # Duplicated!
        port = 587  # Duplicated!
        timeout = 30  # Duplicated!
        # Use these values...

# GOOD: Single source of truth
CLASS EmailConfig:
    SMTP_SERVER = "smtp.gmail.com"
    PORT = 587
    TIMEOUT = 30
    FROM_EMAIL = "noreply@school.edu"

CLASS EmailService:
    METHOD send_welcome_email():
        server = EmailConfig.SMTP_SERVER
        port = EmailConfig.PORT
        # Use config values...

    METHOD send_password_reset():
        server = EmailConfig.SMTP_SERVER  # From config
        port = EmailConfig.PORT  # From config
        # Use config values...

# Now changing server is ONE change
```

## 2. Single Responsibility Principle (SRP)

### The Problem: The "God Class" That Does Everything

**"God Class" Example (Bad):**

```pseudo
# The StudentManager class does TOO MUCH
CLASS StudentManager:
    # Responsibility 1: Student data management
    METHOD add_student(name, age)
    METHOD remove_student(id)
    METHOD update_student_info(id, new_info)

    # Responsibility 2: Grade management
    METHOD add_grade(student_id, subject, grade)
    METHOD calculate_gpa(student_id)
    METHOD generate_report_card(student_id)

    # Responsibility 3: Attendance tracking
    METHOD mark_attendance(student_id, date, present)
    METHOD calculate_attendance_rate(student_id)
    METHOD send_absence_notification(student_id)

    # Responsibility 4: Payment processing
    METHOD process_tuition_payment(student_id, amount)
    METHOD generate_invoice(student_id)
    METHOD send_payment_reminder(student_id)

    # Responsibility 5: Communication
    METHOD send_email(student_id, message)
    METHOD send_sms(student_id, message)
    METHOD send_push_notification(student_id, message)

    # This class has 5 reasons to change!
    # If email service changes → need to modify
    # If payment system changes → need to modify
    # If attendance rules change → need to modify
    # Very fragile and hard to maintain!
```

### The Solution: Single Responsibility Principle

**SRP Principle:** **A class should have only one reason to change.**

Each class should do **one thing** and do it well.

**SRP Code Example:**

```pseudo
# Split into focused, single-purpose classes

# Responsibility 1: Student data only
CLASS StudentRepository:
    METHOD add_student(student)
    METHOD remove_student(id)
    METHOD update_student(id, new_info)
    METHOD find_student(id)

# Responsibility 2: Grade management only
CLASS GradeManager:
    METHOD add_grade(student_id, subject, grade)
    METHOD calculate_gpa(student_id)
    METHOD generate_report_card(student_id)

# Responsibility 3: Attendance only
CLASS AttendanceTracker:
    METHOD mark_attendance(student_id, date, present)
    METHOD calculate_attendance_rate(student_id)
    METHOD get_absent_students(date)

# Responsibility 4: Payments only
CLASS PaymentProcessor:
    METHOD process_payment(student_id, amount, method)
    METHOD generate_invoice(student_id)
    METHOD get_payment_history(student_id)

# Responsibility 5: Notifications only
CLASS NotificationService:
    METHOD send_email(recipient, subject, body)
    METHOD send_sms(phone, message)
    METHOD send_push_notification(device_token, message)

# Responsibility 6: Coordinate between services
CLASS StudentService:
    PRIVATE student_repo: StudentRepository
    PRIVATE grade_manager: GradeManager
    PRIVATE attendance_tracker: AttendanceTracker
    PRIVATE payment_processor: PaymentProcessor
    PRIVATE notifier: NotificationService

    METHOD enroll_new_student(name, age, email):
        # Use specialized classes
        student = student_repo.add_student(name, age, email)
        notifier.send_welcome_email(student.email)
        RETURN student

    METHOD process_student_graduation(student_id):
        student = student_repo.find_student(student_id)
        gpa = grade_manager.calculate_gpa(student_id)
        attendance = attendance_tracker.calculate_attendance_rate(student_id)

        IF gpa >= 2.0 AND attendance >= 0.9:
            # Student can graduate
            payment_processor.generate_final_invoice(student_id)
            notifier.send_graduation_notice(student.email)
            RETURN true

        RETURN false
```

### Real-World Analogy: Restaurant Staff

**"God Employee" Restaurant (Bad):**

- One employee who:
  - Takes orders
  - Cooks food
  - Cleans tables
  - Handles payments
  - Manages inventory
  - (Everything breaks if they get sick!)

**SRP Restaurant (Good):**

- **Host:** Greets and seats customers
- **Waiter:** Takes orders and serves food
- **Chef:** Cooks food
- **Cashier:** Handles payments
- **Cleaner:** Cleans tables
- **Manager:** Coordinates everything
- (System works even if one person is absent)

### SRP Benefits:

1. **Easier to understand** - Each class does one clear thing
2. **Easier to test** - Can test each responsibility separately
3. **Easier to maintain** - Changes affect only one area
4. **Easier to reuse** - Can use GradeManager in different systems

### How to Apply SRP:

Ask: **"What is this class's responsibility?"**

- If you use "and" in the answer → probably violating SRP
- "This class manages students **and** grades **and** attendance **and**..." → BAD
- "This class manages student data" → GOOD

### SRP in Action: File Processing Example

```pseudo
# BAD: One class does everything
CLASS FileProcessor:
    METHOD read_file(path):
        # Read file
        content = READ_FILE(path)
        RETURN content

    METHOD parse_content(content):
        # Parse content
        data = PARSE_JSON(content)
        RETURN data

    METHOD validate_data(data):
        # Validate data
        IF data IS VALID:
            RETURN true
        RETURN false

    METHOD save_to_database(data):
        # Save to database
        DATABASE.insert(data)

    METHOD send_notification():
        # Send notification
        SEND_EMAIL("admin@example.com", "File processed")

    # This class has 5 responsibilities!

# GOOD: Separate classes for each responsibility
CLASS FileReader:
    METHOD read_file(path):
        RETURN READ_FILE(path)

CLASS DataParser:
    METHOD parse_json(content):
        RETURN PARSE_JSON(content)

    METHOD parse_csv(content):
        RETURN PARSE_CSV(content)

CLASS DataValidator:
    METHOD validate(data, schema):
        RETURN VALIDATE_AGAINST_SCHEMA(data, schema)

CLASS DatabaseWriter:
    METHOD insert(data, table):
        DATABASE.insert(table, data)

CLASS Notifier:
    METHOD send_email(to, subject, body):
        EMAIL_SERVICE.send(to, subject, body)

# Coordinator class
CLASS FileProcessingService:
    PRIVATE reader: FileReader
    PRIVATE parser: DataParser
    PRIVATE validator: DataValidator
    PRIVATE writer: DatabaseWriter
    PRIVATE notifier: Notifier

    METHOD process_file(path):
        # Step 1: Read
        content = reader.read_file(path)

        # Step 2: Parse
        data = parser.parse_json(content)

        # Step 3: Validate
        IF NOT validator.validate(data):
            notifier.send_email("admin@example.com", "Validation Failed", "File invalid")
            RETURN false

        # Step 4: Save
        writer.insert(data, "files")

        # Step 5: Notify
        notifier.send_email("admin@example.com", "File Processed", "Success!")

        RETURN true
```

## 3. Loose Coupling

### The Problem: Tightly Coupled "Spaghetti Code"

**Tight Coupling Example:**

```pseudo
# Classes are tightly bound together
CLASS MySQLDatabase:
    METHOD connect():
        PRINT "Connecting to MySQL..."

    METHOD query(sql):
        PRINT "Executing MySQL query: " + sql

CLASS ReportGenerator:
    PRIVATE database: MySQLDatabase  # Direct dependency on MySQL

    METHOD generate_report():
        # Can ONLY work with MySQL
        database.connect()
        data = database.query("SELECT * FROM sales")
        # Generate report...
        PRINT "Report generated using MySQL"

# Problem: What if we want to use PostgreSQL instead?
# We have to CHANGE ReportGenerator class!
# What if we want to test without a real database?
# We CAN'T - it's tightly coupled to MySQL!
```

### The Solution: Loose Coupling

**Loose Coupling Principle:** **Classes should depend on abstractions (interfaces) not concrete implementations.**

**Loose Coupling Example:**

```pseudo
# Step 1: Define an interface
INTERFACE Database:
    METHOD connect()
    METHOD query(sql)

# Step 2: Implement the interface for different databases
CLASS MySQLDatabase IMPLEMENTS Database:
    METHOD connect():
        PRINT "Connecting to MySQL..."

    METHOD query(sql):
        PRINT "Executing MySQL query: " + sql
        # Actual MySQL implementation

CLASS PostgreSQLDatabase IMPLEMENTS Database:
    METHOD connect():
        PRINT "Connecting to PostgreSQL..."

    METHOD query(sql):
        PRINT "Executing PostgreSQL query: " + sql
        # Actual PostgreSQL implementation

# Step 3: For testing
CLASS MockDatabase IMPLEMENTS Database:
    METHOD connect():
        PRINT "Mock: Connected"

    METHOD query(sql):
        PRINT "Mock: Executed " + sql
        RETURN [{"test": "data"}]  # Return test data

# Step 4: ReportGenerator depends on INTERFACE, not implementation
CLASS ReportGenerator:
    PRIVATE database: Database  # Depends on interface!

    METHOD INITIALIZE(db: Database):  # Accepts ANY Database
        database = db

    METHOD generate_report():
        database.connect()
        data = database.query("SELECT * FROM sales")
        # Generate report...
        PRINT "Report generated"

# Usage - we can easily swap databases!
mysql_db = NEW MySQLDatabase()
postgres_db = NEW PostgreSQLDatabase()
mock_db = NEW MockDatabase()

# Same ReportGenerator works with ANY database
report1 = NEW ReportGenerator(mysql_db)
report1.generate_report()  # Uses MySQL

report2 = NEW ReportGenerator(postgres_db)
report2.generate_report()  # Uses PostgreSQL

# For testing
test_report = NEW ReportGenerator(mock_db)
test_report.generate_report()  # Uses mock - no real database needed!
```

### Real-World Analogy: Power Adapters

**Tightly Coupled (Bad):**

- Your laptop charger is hardwired to one specific outlet type
- Travel to another country? Can't charge your laptop!

**Loosely Coupled (Good):**

- Your laptop charger has a detachable cable
- Travel to another country? Just swap the plug adapter!
- The laptop doesn't care about the outlet type

### Loose Coupling Benefits:

1. **Flexibility** - Easy to swap implementations
2. **Testability** - Can use mocks for testing
3. **Maintainability** - Changes in one class don't break others
4. **Reusability** - Components can be used in different contexts

### Dependency Injection Pattern

The most common way to achieve loose coupling is **Dependency Injection** - passing dependencies into a class rather than creating them inside.

```pseudo
# BAD: Tight coupling - creates dependency inside
CLASS OrderService:
    PRIVATE payment_processor

    METHOD INITIALIZE():
        payment_processor = NEW PayPalProcessor()  # Hardcoded!
        # Can't use Stripe without changing code!

    METHOD process_order(amount):
        payment_processor.charge(amount)

# GOOD: Loose coupling - dependency injected
CLASS OrderService:
    PRIVATE payment_processor

    METHOD INITIALIZE(processor: PaymentProcessor):  # Accepts interface
        payment_processor = processor  # Injected from outside!

    METHOD process_order(amount):
        payment_processor.charge(amount)

# Now we can inject ANY PaymentProcessor
paypal_service = NEW OrderService(NEW PayPalProcessor())
stripe_service = NEW OrderService(NEW StripeProcessor())
test_service = NEW OrderService(NEW MockProcessor())  # For testing
```

### Loose Coupling in Action: Notification System

```pseudo
# Define interfaces
INTERFACE MessageSender:
    METHOD send(message, recipient)

INTERFACE Logger:
    METHOD log(message, level)

# Concrete implementations
CLASS EmailSender IMPLEMENTS MessageSender:
    METHOD send(message, recipient):
        PRINT "Sending email to " + recipient + ": " + message

CLASS SMSSender IMPLEMENTS MessageSender:
    METHOD send(message, recipient):
        PRINT "Sending SMS to " + recipient + ": " + message

CLASS FileLogger IMPLEMENTS Logger:
    METHOD log(message, level):
        PRINT "[" + level + "] " + message + " (logged to file)"

CLASS ConsoleLogger IMPLEMENTS Logger:
    METHOD log(message, level):
        PRINT "[" + level + "] " + message

# Service class with loose coupling
CLASS NotificationService:
    PRIVATE sender: MessageSender  # Depends on interface
    PRIVATE logger: Logger         # Depends on interface

    METHOD INITIALIZE(msg_sender: MessageSender, log: Logger):
        sender = msg_sender
        logger = log

    METHOD notify_user(user, message):
        logger.log("Notifying user: " + user.name, "INFO")

        TRY:
            sender.send(message, user.contact)
            logger.log("Notification sent successfully", "INFO")
        CATCH error:
            logger.log("Failed to send notification: " + error, "ERROR")

# Usage - we can mix and match implementations!
users = [NEW User("Alice", "alice@email.com"), NEW User("Bob", "+1234567890")]

# Scenario 1: Email notifications with file logging
email_service = NEW NotificationService(
    NEW EmailSender(),
    NEW FileLogger()
)

# Scenario 2: SMS notifications with console logging
sms_service = NEW NotificationService(
    NEW SMSSender(),
    NEW ConsoleLogger()
)

# Scenario 3: For testing - mock implementations
mock_service = NEW NotificationService(
    NEW MockSender(),
    NEW MockLogger()
)

# All work with the same NotificationService class!
```

## Putting It All Together: A Complete Example

Let's build a simple library system using all three principles:

```pseudo
# ========== DRY: Reusable Components ==========

# Reusable validation (DRY)
CLASS ValidationUtils:
    STATIC METHOD is_valid_isbn(isbn):
        # ISBN validation logic in ONE place
        RETURN LENGTH(isbn) == 10 OR LENGTH(isbn) == 13

    STATIC METHOD is_valid_email(email):
        # Email validation logic in ONE place
        RETURN email CONTAINS "@" AND email CONTAINS "."

    STATIC METHOD is_within_range(value, min, max):
        # Range check logic in ONE place
        RETURN value >= min AND value <= max

# Reusable date utilities (DRY)
CLASS DateUtils:
    STATIC METHOD get_due_date(days_from_now):
        today = CURRENT_DATE()
        RETURN ADD_DAYS(today, days_from_now)

    STATIC METHOD is_overdue(due_date):
        RETURN CURRENT_DATE() > due_date

# ========== SRP: Single Responsibility Classes ==========

# Book entity - only manages book data
CLASS Book:
    PRIVATE isbn
    PRIVATE title
    PRIVATE author
    PRIVATE is_available

    METHOD INITIALIZE(book_isbn, book_title, book_author):
        IF NOT ValidationUtils.is_valid_isbn(book_isbn):
            ERROR "Invalid ISBN"
        isbn = book_isbn
        title = book_title
        author = book_author
        is_available = true

# Member entity - only manages member data
CLASS Member:
    PRIVATE member_id
    PRIVATE name
    PRIVATE email
    PRIVATE join_date

    METHOD INITIALIZE(id, member_name, member_email):
        IF NOT ValidationUtils.is_valid_email(member_email):
            ERROR "Invalid email"
        member_id = id
        name = member_name
        email = member_email
        join_date = CURRENT_DATE()

# Loan entity - only manages loan data
CLASS Loan:
    PRIVATE loan_id
    PRIVATE book
    PRIVATE member
    PRIVATE borrow_date
    PRIVATE due_date
    PRIVATE returned_date

    METHOD INITIALIZE(loan_id, loan_book, loan_member, loan_duration_days):
        loan_id = loan_id
        book = loan_book
        member = loan_member
        borrow_date = CURRENT_DATE()
        due_date = DateUtils.get_due_date(loan_duration_days)
        returned_date = null

# ========== LOOSE COUPLING: Interfaces and Dependency Injection ==========

# Repository interfaces
INTERFACE BookRepository:
    METHOD save(book)
    METHOD find_by_isbn(isbn)
    METHOD find_all_available()

INTERFACE MemberRepository:
    METHOD save(member)
    METHOD find_by_id(member_id)
    METHOD find_by_email(email)

INTERFACE LoanRepository:
    METHOD save(loan)
    METHOD find_active_loans_by_member(member_id)
    METHOD find_overdue_loans()

# Notification interface
INTERFACE Notifier:
    METHOD send_overdue_notification(loan)
    METHOD send_reminder(loan, days_before_due)

# Concrete implementations (could be swapped)
CLASS InMemoryBookRepository IMPLEMENTS BookRepository:
    # Implementation using memory...

CLASS DatabaseBookRepository IMPLEMENTS BookRepository:
    # Implementation using database...

CLASS EmailNotifier IMPLEMENTS Notifier:
    METHOD send_overdue_notification(loan):
        PRINT "Email sent to " + loan.member.email + ": Book overdue!"

    METHOD send_reminder(loan, days_before_due):
        PRINT "Reminder email sent for book due in " + days_before_due + " days"

# ========== MAIN SERVICE: Coordinating with loose coupling ==========

CLASS LibraryService:
    PRIVATE book_repo: BookRepository
    PRIVATE member_repo: MemberRepository
    PRIVATE loan_repo: LoanRepository
    PRIVATE notifier: Notifier

    # Dependency Injection: All dependencies provided from outside
    METHOD INITIALIZE(books: BookRepository, members: MemberRepository,
                     loans: LoanRepository, notification: Notifier):
        book_repo = books
        member_repo = members
        loan_repo = loans
        notifier = notification

    # SRP: This service coordinates, doesn't do everything itself
    METHOD borrow_book(member_id, isbn, duration_days = 14):
        # Step 1: Find book
        book = book_repo.find_by_isbn(isbn)
        IF book == null OR NOT book.is_available:
            RETURN "Book not available"

        # Step 2: Find member
        member = member_repo.find_by_id(member_id)
        IF member == null:
            RETURN "Member not found"

        # Step 3: Check if member has too many loans (DRY: using utility)
        active_loans = loan_repo.find_active_loans_by_member(member_id)
        IF LENGTH(active_loans) >= 5:  # Max 5 books
            RETURN "Maximum loans reached"

        # Step 4: Create loan
        loan = NEW Loan(GENERATE_ID(), book, member, duration_days)
        loan_repo.save(loan)

        # Step 5: Update book status
        book.is_available = false
        book_repo.save(book)

        # Step 6: Send reminder (loose coupling via interface)
        notifier.send_reminder(loan, 3)  # Remind 3 days before due

        RETURN "Book borrowed successfully. Due: " + loan.due_date

    METHOD return_book(loan_id):
        # Similar coordinated process...
        # Returns book, updates status, checks for overdue fees

    METHOD check_overdue_books():
        overdue_loans = loan_repo.find_overdue_loans()
        FOR loan IN overdue_loans:
            # Loose coupling: notifier could be email, SMS, etc.
            notifier.send_overdue_notification(loan)
        RETURN LENGTH(overdue_loans)

# ========== USAGE ==========

# For production: Use real implementations
production_service = NEW LibraryService(
    NEW DatabaseBookRepository(),
    NEW DatabaseMemberRepository(),
    NEW DatabaseLoanRepository(),
    NEW EmailNotifier()
)

# For testing: Use mock implementations
test_service = NEW LibraryService(
    NEW MockBookRepository(),
    NEW MockMemberRepository(),
    NEW MockLoanRepository(),
    NEW MockNotifier()
)

# For in-memory demo (e.g., web demo)
demo_service = NEW LibraryService(
    NEW InMemoryBookRepository(),
    NEW InMemoryMemberRepository(),
    NEW InMemoryLoanRepository(),
    NEW ConsoleNotifier()  # Just prints to console
)
```

## Quick Reference Guide

| Principle          | Bad Smell (What to Avoid)            | Good Practice (What to Do)                | Simple Test                                               |
| ------------------ | ------------------------------------ | ----------------------------------------- | --------------------------------------------------------- |
| **DRY**            | Same code in multiple places         | Extract to reusable method/class          | "Would I need to change this in more than one place?"     |
| **SRP**            | Class doing many unrelated things    | One responsibility per class              | "Can I describe the class's purpose without using 'and'?" |
| **Loose Coupling** | Direct instantiation of dependencies | Depend on interfaces, inject dependencies | "Can I swap implementations without changing this class?" |

## Common Anti-Patterns to Avoid

### 1. The "Swiss Army Knife" Class

```pseudo
# ANTI-PATTERN: One class that does everything
CLASS Utility:
    METHOD calculate_tax(amount)
    METHOD format_date(date)
    METHOD validate_email(email)
    METHOD encrypt_password(password)
    METHOD generate_report(data)
    METHOD send_email(to, message)
    # ... and 50 more methods!

# SOLUTION: Separate specialized classes
CLASS TaxCalculator
CLASS DateFormatter
CLASS EmailValidator
CLASS PasswordEncryptor
CLASS ReportGenerator
CLASS EmailSender
```

### 2. The "Copy-Paste Programmer"

```pseudo
# ANTI-PATTERN: Copying code instead of reusing
# File: StudentService.pseudo
METHOD calculate_gpa(student_id):
    # 20 lines of GPA calculation

# File: ReportService.pseudo
METHOD calculate_gpa(student_id):
    # Same 20 lines copied!

# File: AnalyticsService.pseudo
METHOD calculate_gpa(student_id):
    # Same 20 lines copied again!

# SOLUTION: Extract to common service
CLASS GradeService:
    METHOD calculate_gpa(student_id):
        # One implementation used by all
```

### 3. The "Concrete Prison"

```pseudo
# ANTI-PATTERN: Hardcoded dependencies
CLASS PaymentService:
    METHOD process_payment():
        # Can ONLY use Stripe
        processor = NEW StripeProcessor()
        processor.charge()

# SOLUTION: Use interfaces and dependency injection
INTERFACE PaymentProcessor:
    METHOD charge(amount)

CLASS PaymentService:
    METHOD INITIALIZE(processor: PaymentProcessor):
        # Can use ANY processor
        self.processor = processor
```

## Practice Exercise: E-commerce System Refactor

Refactor this poorly designed e-commerce code using DRY, SRP, and Loose Coupling principles:

```pseudo
# POORLY DESIGNED CODE - REFACTOR THIS!

CLASS ECommerceSystem:
    # Violates SRP: Does everything!
    # Violates DRY: Duplicate validation/logic
    # Violates Loose Coupling: Hardcoded dependencies

    METHOD process_order(order_data):
        # Validate order
        IF order_data.customer_email DOES NOT CONTAIN "@":
            PRINT "Invalid email"
            RETURN

        # Calculate tax (duplicated elsewhere)
        tax = order_data.subtotal * 0.08

        # Process payment (hardcoded to PayPal)
        PRINT "Processing PayPal payment..."
        # PayPal specific code...

        # Update inventory (duplicated logic)
        FOR item IN order_data.items:
            # Inventory update logic...
            PRINT "Updating inventory for " + item.name

        # Send confirmation email
        PRINT "Sending email to " + order_data.customer_email
        # Email sending code...

        # Generate invoice
        invoice_number = "INV-" + GENERATE_RANDOM_NUMBER()
        PRINT "Invoice generated: " + invoice_number

        # Log transaction
        PRINT "Logging transaction..."
        # Logging code...

        RETURN "Order processed"

    # More methods that do even more things...
    METHOD generate_sales_report():
        # Also calculates tax, sends emails, etc.
        pass

    METHOD handle_refund():
        # Also validates, sends emails, etc.
        pass
```

**Your Task:** Refactor this into a well-designed system with:

1. **DRY:** Extract duplicate calculations and validations
2. **SRP:** Separate into focused classes
3. **Loose Coupling:** Use interfaces for payment, email, logging

**Hints:**

- Create separate classes: `OrderValidator`, `TaxCalculator`, `PaymentProcessor`, `InventoryManager`, `EmailService`, `InvoiceGenerator`, `Logger`
- Define interfaces: `PaymentGateway`, `NotificationService`
- Create a coordinating `OrderService` that uses these components

## Quick Check

1. **What does DRY stand for and why is it important?**

   - Don't Repeat Yourself. Important because changes need to be made in only one place.

2. **What's the "one reason to change" in SRP?**

   - A class should have only one responsibility, so it only changes when that responsibility's requirements change.

3. **How does loose coupling make testing easier?**

   - You can replace real dependencies with mock objects for testing.

4. **What's the difference between tight and loose coupling?**

   - Tight coupling: Classes directly depend on concrete implementations
   - Loose coupling: Classes depend on abstractions/interfaces

5. **Which principle is violated when you copy-paste code?**

   - DRY (Don't Repeat Yourself)

6. **What question helps identify SRP violations?**

   - "Can I describe what this class does without using the word 'and'?"

7. **How does dependency injection help with loose coupling?**

   - Dependencies are provided from outside, so implementations can be easily swapped.

---

**Next Chapter:** [Part 4: From Design to Patterns](./part4/chapter4-1.md) where we'll explore design patterns like Singleton, Observer, and Factory!

> **Key Insight:** These three principles work together like a well-oiled machine. DRY keeps your code concise, SRP keeps it organized, and Loose Coupling keeps it flexible. Mastering these principles will transform you from a coder who writes working software to a designer who creates maintainable, scalable systems. Remember: good design isn't about making code work—it's about making code easy to change.
