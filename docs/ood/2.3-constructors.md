# Chapter 2.3: Constructors - The Birth of an Object

## Introduction: Creating Objects Properly

Think about what happens when a new student joins your school. They don't just appear out of nowhere with no information! The school office creates a **new student record** with their name, age, grade level, and assigns them a student ID. This process of **initial creation with proper setup** is exactly what constructors do in Object-Oriented Design.

## What Are Constructors?

**Constructors** are special methods that are called automatically when an object is created. Their job is to **initialize the object** - set up its initial state, allocate resources, and prepare it for use.

### The Problem Without Constructors

```pseudo
# WITHOUT constructors - messy and error-prone
CLASS Student:
    name
    age
    grade
    student_id

# Creating a student object
alex = NEW Student()
# Now we have to set everything manually...
alex.name = "Alex"
alex.age = 15
alex.grade = "10th"
alex.student_id = "STU-2023-001"

# What if we forget to set something?
bella = NEW Student()
bella.name = "Bella"
# Forgot age, grade, student_id... object is in incomplete state!
```

### The Solution With Constructors

```pseudo
# WITH constructors - clean and reliable
CLASS Student:
    PRIVATE name
    PRIVATE age
    PRIVATE grade
    PRIVATE student_id

    # Constructor - sets up the object properly
    METHOD INITIALIZE(student_name, student_age, student_grade, id):
        name = student_name
        age = student_age
        grade = student_grade
        student_id = id
        PRINT "New student created: " + name + " (ID: " + id + ")"

# Creating objects is now simple and complete
alex = NEW Student("Alex Johnson", 15, "10th", "STU-2023-001")
# All attributes are properly initialized!
```

## Types of Constructors

### 1. Default Constructor (No Parameters)

A constructor with no parameters that sets default values.

```pseudo
CLASS Book:
    PRIVATE title
    PRIVATE author
    PRIVATE is_available

    # Default constructor
    METHOD INITIALIZE():
        title = "Unknown Title"
        author = "Unknown Author"
        is_available = true
        PRINT "Default book created"

# Usage
unknown_book = NEW Book()  # Uses default constructor
# Result: title="Unknown Title", author="Unknown Author", is_available=true
```

### 2. Parameterized Constructor

A constructor that accepts parameters to initialize attributes with specific values.

```pseudo
CLASS Rectangle:
    PRIVATE width
    PRIVATE height
    PRIVATE color

    # Parameterized constructor
    METHOD INITIALIZE(rect_width, rect_height, rect_color):
        width = rect_width
        height = rect_height
        color = rect_color
        PRINT "Rectangle created: " + width + "×" + height + " " + color

# Usage
my_rect = NEW Rectangle(10, 5, "blue")
# Result: width=10, height=5, color="blue"
```

### 3. Copy Constructor

A constructor that creates a new object as a copy of an existing object.

```pseudo
CLASS Student:
    PRIVATE name
    PRIVATE age
    PRIVATE grades

    # Regular constructor
    METHOD INITIALIZE(student_name, student_age):
        name = student_name
        age = student_age
        grades = []

    # Copy constructor
    METHOD INITIALIZE_FROM_EXISTING(other_student):
        name = other_student.name
        age = other_student.age
        grades = COPY(other_student.grades)  # Important: Copy the list, not reference!
        PRINT "Created copy of " + name

# Usage
original = NEW Student("Alex", 15)
original.grades = [90, 85, 95]

copy = NEW Student(original)  # Using copy constructor
# 'copy' is a new independent object with same values
```

## Constructor Overloading

Just like regular methods, constructors can be **overloaded** - having multiple constructors with different parameters.

```pseudo
CLASS BankAccount:
    PRIVATE account_number
    PRIVATE account_holder
    PRIVATE balance
    PRIVATE account_type

    # Constructor 1: Minimum required info
    METHOD INITIALIZE(number, holder):
        account_number = number
        account_holder = holder
        balance = 0.0
        account_type = "checking"
        PRINT "Basic account created for " + holder

    # Constructor 2: With initial balance
    METHOD INITIALIZE(number, holder, initial_balance):
        account_number = number
        account_holder = holder
        balance = initial_balance
        account_type = "checking"
        PRINT "Account created for " + holder + " with $" + initial_balance

    # Constructor 3: Full specification
    METHOD INITIALIZE(number, holder, initial_balance, type):
        account_number = number
        account_holder = holder
        balance = initial_balance
        account_type = type
        PRINT type + " account created for " + holder + " with $" + initial_balance

# Different ways to create accounts
account1 = NEW BankAccount("ACC001", "Alice")  # Uses constructor 1
account2 = NEW BankAccount("ACC002", "Bob", 1000)  # Uses constructor 2
account3 = NEW BankAccount("ACC003", "Charlie", 5000, "savings")  # Uses constructor 3
```

## The Constructor's Job: Initialization Checklist

A good constructor should:

1. **Set all attributes** to valid initial values
2. **Validate parameters** to prevent invalid states
3. **Allocate resources** if needed (memory, files, connections)
4. **Establish invariants** - conditions that must always be true
5. **Set up relationships** with other objects

```pseudo
CLASS Email:
    PRIVATE sender
    PRIVATE recipient
    PRIVATE subject
    PRIVATE body
    PRIVATE timestamp
    PRIVATE is_sent

    METHOD INITIALIZE(from_address, to_address, email_subject, email_body):
        # 1. Validate parameters
        IF NOT is_valid_email(from_address):
            ERROR "Invalid sender email"
        IF NOT is_valid_email(to_address):
            ERROR "Invalid recipient email"
        IF email_subject == "":
            ERROR "Subject cannot be empty"

        # 2. Set attributes
        sender = from_address
        recipient = to_address
        subject = email_subject
        body = email_body

        # 3. Set derived attributes
        timestamp = CURRENT_TIME()
        is_sent = false

        # 4. Log creation
        LOG "Email draft created: " + subject + " from " + sender + " to " + recipient

        # 5. Invariant: Unsent email must have all required fields
        # This condition will always be true after constructor
```

## Constructor Chaining

When a class inherits from another class, constructors can call parent constructors.

```pseudo
CLASS Person:
    PRIVATE name
    PRIVATE age

    METHOD INITIALIZE(person_name, person_age):
        name = person_name
        age = person_age
        PRINT "Person created: " + name

CLASS Student EXTENDS Person:
    PRIVATE student_id
    PRIVATE grade

    # Student constructor calls Person constructor
    METHOD INITIALIZE(student_name, student_age, id, student_grade):
        # Call parent constructor first
        SUPER.INITIALIZE(student_name, student_age)

        # Then initialize Student-specific attributes
        student_id = id
        grade = student_grade
        PRINT "Student registered: " + student_id

# Usage
alex = NEW Student("Alex", 15, "STU001", "10th")
# Output:
# "Person created: Alex"
# "Student registered: STU001"
```

## Real-World Examples

### Example 1: E-commerce Product with Validation

```pseudo
CLASS Product:
    PRIVATE id
    PRIVATE name
    PRIVATE price
    PRIVATE category
    PRIVATE stock_quantity
    PRIVATE created_date

    METHOD INITIALIZE(product_id, product_name, product_price,
                     product_category, quantity):

        # Validation
        IF product_id == "":
            ERROR "Product ID cannot be empty"
        IF product_name == "":
            ERROR "Product name cannot be empty"
        IF product_price <= 0:
            ERROR "Price must be positive"
        IF quantity < 0:
            ERROR "Stock quantity cannot be negative"

        # Set attributes
        id = product_id
        name = product_name
        price = product_price
        category = product_category
        stock_quantity = quantity
        created_date = CURRENT_DATE()

        # Log creation
        LOG "Product created: " + id + " - " + name + " ($" + price + ")"

        # Initial business logic
        IF quantity == 0:
            LOG "Warning: Product " + id + " created with zero stock"

    # Alternative constructor for products without category
    METHOD INITIALIZE(product_id, product_name, product_price, quantity):
        # Call the main constructor with default category
        INITIALIZE(product_id, product_name, product_price, "Uncategorized", quantity)

# Usage
laptop = NEW Product("P-001", "Gaming Laptop", 1299.99, "Electronics", 50)
# Creates product with all attributes set
```

### Example 2: Social Media User Account

```pseudo
CLASS UserAccount:
    PRIVATE username
    PRIVATE email
    PRIVATE password_hash
    PRIVATE join_date
    PRIVATE is_active
    PRIVATE profile_picture
    PRIVATE friends_list
    PRIVATE posts

    METHOD INITIALIZE(new_username, user_email, plain_password):
        # Validate input
        IF LENGTH(new_username) < 3:
            ERROR "Username must be at least 3 characters"
        IF NOT is_valid_email(user_email):
            ERROR "Invalid email address"
        IF LENGTH(plain_password) < 8:
            ERROR "Password must be at least 8 characters"

        # Check if username/email already exists (would query database in real app)
        IF username_exists(new_username):
            ERROR "Username already taken"
        IF email_exists(user_email):
            ERROR "Email already registered"

        # Set attributes
        username = new_username
        email = user_email
        password_hash = hash_password(plain_password)  # Never store plain passwords!
        join_date = CURRENT_DATE()
        is_active = true
        profile_picture = "default_avatar.jpg"
        friends_list = []
        posts = []

        # Send welcome email (in background)
        send_welcome_email(email, username)

        # Log account creation
        LOG "New user account created: " + username + " (" + email + ")"

        # Initial setup
        create_default_folders()
        follow_suggested_accounts()

    # Private helper methods
    PRIVATE METHOD hash_password(password):
        # Use secure hashing algorithm
        RETURN SECURE_HASH(password)

    PRIVATE METHOD send_welcome_email(to_address, user_name):
        # This would connect to email service
        PRINT "Sending welcome email to " + to_address
        # Actual email sending code here...

# Usage
new_user = NEW UserAccount("alex_j", "alex@example.com", "securePass123")
# Account is fully initialized and ready to use
```

### Example 3: Game Character Creation

```pseudo
CLASS GameCharacter:
    PRIVATE name
    PRIVATE character_class
    PRIVATE level
    PRIVATE health
    PRIVATE mana
    PRIVATE experience
    PRIVATE inventory
    PRIVATE skills
    PRIVATE position

    # Main constructor for new characters
    METHOD INITIALIZE(char_name, char_class):
        # Validate
        IF char_name == "":
            ERROR "Character name required"
        VALID_CLASSES = ["Warrior", "Mage", "Archer", "Rogue"]
        IF NOT (char_class IN VALID_CLASSES):
            ERROR "Invalid character class"

        # Set basic attributes
        name = char_name
        character_class = char_class
        level = 1
        experience = 0

        # Set class-specific starting values
        IF char_class == "Warrior":
            health = 150
            mana = 30
            inventory = ["iron_sword", "wooden_shield", "health_potion"]
            skills = ["slash", "block"]
        ELSE IF char_class == "Mage":
            health = 80
            mana = 100
            inventory = ["oak_staff", "mana_potion", "mana_potion"]
            skills = ["fireball", "heal", "teleport"]
        ELSE IF char_class == "Archer":
            health = 100
            mana = 50
            inventory = ["longbow", "arrow×20", "health_potion"]
            skills = ["shoot", "rapid_fire", "dodge"]
        ELSE IF char_class == "Rogue":
            health = 90
            mana = 60
            inventory = ["dagger", "lockpick", "invisibility_potion"]
            skills = ["backstab", "stealth", "pick_lock"]

        # Starting position
        position = {"x": 100, "y": 100, "zone": "Starting Village"}

        # Welcome message
        PRINT "Welcome, " + name + " the " + char_class + "!"
        PRINT "You start with " + health + " HP and " + mana + " MP"
        PRINT "Location: " + position.zone

    # Constructor for loading saved characters
    METHOD INITIALIZE_LOADED(data):
        name = data.name
        character_class = data.class
        level = data.level
        health = data.health
        mana = data.mana
        experience = data.experience
        inventory = data.inventory
        skills = data.skills
        position = data.position
        PRINT "Welcome back, " + name + " (Level " + level + " " + character_class + ")"

# Usage
new_hero = NEW GameCharacter("Aragon", "Warrior")
# Output:
# "Welcome, Aragon the Warrior!"
# "You start with 150 HP and 30 MP"
# "Location: Starting Village"
```

## Factory Methods: Alternative Object Creation

Sometimes, constructors aren't enough. **Factory methods** are static methods that create and return objects, often with more complex logic.

```pseudo
CLASS Notification:
    PRIVATE type
    PRIVATE message
    PRIVATE recipient

    # Private constructor - can't create directly
    PRIVATE METHOD INITIALIZE(notif_type, notif_message, notif_recipient):
        type = notif_type
        message = notif_message
        recipient = notif_recipient

    # Factory methods
    STATIC METHOD create_email_notification(email_address, subject, body):
        notification = NEW Notification()
        notification.type = "email"
        notification.message = {"subject": subject, "body": body}
        notification.recipient = email_address
        RETURN notification

    STATIC METHOD create_sms_notification(phone_number, text):
        notification = NEW Notification()
        notification.type = "sms"
        notification.message = text
        notification.recipient = phone_number
        RETURN notification

    STATIC METHOD create_push_notification(device_token, title, content):
        notification = NEW Notification()
        notification.type = "push"
        notification.message = {"title": title, "content": content}
        notification.recipient = device_token
        RETURN notification

# Usage - much clearer than constructor with many parameters
email_notif = Notification.create_email_notification(
    "user@example.com",
    "Welcome!",
    "Thanks for joining!"
)

sms_notif = Notification.create_sms_notification(
    "+1234567890",
    "Your code is 123456"
)
```

## Common Constructor Patterns

### 1. Builder Pattern for Complex Objects

```pseudo
CLASS Computer:
    PRIVATE cpu
    PRIVATE ram
    PRIVATE storage
    PRIVATE gpu
    PRIVATE os

    # Private constructor - use Builder to create
    PRIVATE METHOD INITIALIZE():
        # Default values
        cpu = "Intel i5"
        ram = 8
        storage = 256
        gpu = "Integrated"
        os = "Windows 10"

    # Builder class
    CLASS ComputerBuilder:
        PRIVATE computer

        METHOD INITIALIZE():
            computer = NEW Computer()

        METHOD set_cpu(cpu_model):
            computer.cpu = cpu_model
            RETURN self

        METHOD set_ram(ram_gb):
            computer.ram = ram_gb
            RETURN self

        METHOD set_storage(storage_gb):
            computer.storage = storage_gb
            RETURN self

        METHOD set_gpu(gpu_model):
            computer.gpu = gpu_model
            RETURN self

        METHOD set_os(operating_system):
            computer.os = operating_system
            RETURN self

        METHOD build():
            RETURN computer

# Usage
gaming_pc = NEW Computer.ComputerBuilder()
    .set_cpu("Intel i9")
    .set_ram(32)
    .set_storage(1000)
    .set_gpu("NVIDIA RTX 3080")
    .set_os("Windows 11")
    .build()
```

### 2. Singleton Pattern Constructor

```pseudo
CLASS DatabaseConnection:
    PRIVATE connection
    PRIVATE instance = null  # Static variable

    # Private constructor - prevents direct creation
    PRIVATE METHOD INITIALIZE():
        connection = connect_to_database()
        PRINT "Database connection established"

    # Static method to get the single instance
    STATIC METHOD get_instance():
        IF instance == null:
            instance = NEW DatabaseConnection()
        RETURN instance

# Usage - always get the same instance
db1 = DatabaseConnection.get_instance()
db2 = DatabaseConnection.get_instance()
# db1 and db2 are the SAME object
```

## Constructor Best Practices

### 1. Keep Constructors Simple

```pseudo
# BAD: Constructor does too much work
METHOD INITIALIZE():
    # 50 lines of complex initialization
    # Network calls, file I/O, complex calculations

# GOOD: Constructor sets up state, delegates complex work
METHOD INITIALIZE():
    set_default_values()
    initialize_components()
    # Complex initialization in separate methods
    setup_network_async()  # Runs in background
```

### 2. Validate Input Parameters

```pseudo
METHOD INITIALIZE(name, age, email):
    IF name == null OR name == "":
        ERROR "Name is required"
    IF age < 0 OR age > 150:
        ERROR "Age must be between 0 and 150"
    IF NOT email CONTAINS "@":
        ERROR "Invalid email address"

    # Only set if validation passes
    this.name = name
    this.age = age
    this.email = email
```

### 3. Don't Call Overridable Methods

```pseudo
# DANGEROUS: Calling overridable method in constructor
CLASS Parent:
    METHOD INITIALIZE():
        setup()  # Child class might override this!

    METHOD setup():
        # Parent implementation

CLASS Child EXTENDS Parent:
    METHOD setup():  # Overrides parent method
        # Child implementation - might use attributes not set yet!

# SAFE: Make method final/private or use template method pattern
```

### 4. Use Default Values Wisely

```pseudo
CLASS Configuration:
    PRIVATE timeout
    PRIVATE retries
    PRIVATE debug_mode

    # Good: Clear default values
    METHOD INITIALIZE():
        timeout = 30  # seconds
        retries = 3
        debug_mode = false

    # Better: Allow customization with defaults
    METHOD INITIALIZE(custom_timeout = 30, custom_retries = 3):
        timeout = custom_timeout
        retries = custom_retries
        debug_mode = false
```

## Common Mistakes to Avoid

### 1. Leaving Attributes Uninitialized

```pseudo
# BAD: What's the initial value of 'score'?
CLASS Student:
    PRIVATE name
    PRIVATE score  # Uninitialized!

    METHOD INITIALIZE(student_name):
        name = student_name
        # Forgot to initialize score!

# GOOD: Always initialize all attributes
CLASS Student:
    PRIVATE name
    PRIVATE score

    METHOD INITIALIZE(student_name):
        name = student_name
        score = 0  # Proper initialization
```

### 2. Creating "Half-Baked" Objects

```pseudo
# BAD: Object needs multiple steps to be usable
order = NEW Order()  # Empty order
order.add_item(item1)  # Have to call these
order.add_item(item2)  # before order is valid
order.set_customer(customer)

# GOOD: Object is fully usable after constructor
order = NEW Order(customer, [item1, item2])  # Complete after creation
```

### 3. Ignoring Resource Cleanup

```pseudo
# BAD: Opens resources but doesn't handle cleanup
CLASS FileHandler:
    PRIVATE file

    METHOD INITIALIZE(filename):
        file = OPEN_FILE(filename)  # Opens file
        # What if object is destroyed? File might stay open!

# BETTER: Provide cleanup method
CLASS FileHandler:
    PRIVATE file

    METHOD INITIALIZE(filename):
        file = OPEN_FILE(filename)

    METHOD close():
        CLOSE_FILE(file)

    # Even better: Use destructor/finalizer if language supports it
```

## Practice Exercise: Library Book Constructor

Design constructors for a `Book` class with the following requirements:

1. **Create three constructors:**

   - Default constructor: Creates a book with default values
   - Basic constructor: Requires title and author only
   - Full constructor: Accepts all book attributes

2. **Add validation:**

   - Title cannot be empty
   - ISBN must be 10 or 13 characters
   - Publication year must be between 1450 and current year
   - Page count must be positive

3. **Implement constructor chaining** where possible
4. **Add a static factory method** `create_ebook(title, author, file_size, format)`

```pseudo
CLASS Book:
    PRIVATE title
    PRIVATE author
    PRIVATE isbn
    PRIVATE publication_year
    PRIVATE page_count
    PRIVATE is_available

    # Default constructor
    METHOD INITIALIZE():
        # Your code here

    # Basic constructor (title and author only)
    METHOD INITIALIZE(book_title, book_author):
        # Your code here

    # Full constructor
    METHOD INITIALIZE(book_title, book_author, book_isbn,
                     year, pages, available = true):
        # Your code here - remember validation!

    # Factory method for ebooks
    STATIC METHOD create_ebook(ebook_title, ebook_author,
                              file_size_mb, file_format):
        # Your code here
        # Hint: Create a regular book then add ebook-specific attributes
```

## Quick Check

1. **What is the main purpose of a constructor?**

   - To initialize an object's state when it's created

2. **What's the difference between a default constructor and a parameterized constructor?**

   - Default: No parameters, sets default values
   - Parameterized: Accepts parameters to set specific values

3. **Why should constructors validate their parameters?**

   - To ensure objects are always in a valid state
   - To prevent errors later when using the object

4. **What is constructor overloading?**

   - Having multiple constructors with different parameters in the same class

5. **What is constructor chaining?**

   - When a constructor calls another constructor (in the same class) or a parent class constructor

---

**Next Chapter:** [Chapter 2.4: Relationships Between Objects](./chapter2-4.md) where we'll explore how objects connect and interact with each other!

> **Key Insight:** A well-designed constructor ensures that every object starts its life in a valid, consistent state. It's like giving every object a proper "birth" with all the information and resources it needs to function correctly. Objects created with good constructors are reliable, predictable, and much easier to work with.
