# Chapter 2.2: Methods & Behavior - What Objects Can Do

## Introduction: Objects in Action

If attributes are **what an object is**, then methods are **what an object does**. Methods define the behaviors and capabilities of objects. They're the actions objects can perform, often using or modifying their internal state.

### Real-World Analogy: A Smartphone

Your smartphone has:

- **Attributes (State):** Battery percentage, storage used, brightness level
- **Methods (Behavior):** `make_call()`, `take_photo()`, `play_music()`, `send_message()`

Methods make objects useful. A car with only attributes (color, model, fuel level) isn't very useful until it can `accelerate()`, `brake()`, and `turn()`.

## What Are Methods?

**Methods** are functions defined inside a class that describe the behaviors of objects created from that class. They can:

1. Use the object's attributes
2. Modify the object's state
3. Return values
4. Interact with other objects
5. Perform calculations or operations

## Basic Method Structure

```pseudo
CLASS ClassName:
    # Attributes here...

    # Method definition
    METHOD method_name(parameter1, parameter2, ...):
        # Method body - what the method does
        # Can use object's attributes
        # Can use parameters
        # Optionally return a value
```

## Types of Methods

### 1. Accessor Methods (Getters)

Methods that **read** or **return** attribute values without modifying them.

```pseudo
CLASS BankAccount:
    PRIVATE balance
    PRIVATE account_holder

    # Getter methods - return attribute values
    METHOD get_balance():
        RETURN balance

    METHOD get_account_holder():
        RETURN account_holder

    METHOD get_account_summary():
        # Returns formatted information
        RETURN "Account Holder: " + account_holder + "\n" +
               "Balance: $" + balance
```

### 2. Mutator Methods (Setters)

Methods that **modify** or **update** attribute values.

```pseudo
CLASS Student:
    PRIVATE name
    PRIVATE grade
    PRIVATE attendance

    # Setter methods - modify attributes
    METHOD set_name(new_name):
        IF LENGTH(new_name) > 0:
            name = new_name

    METHOD update_grade(new_grade):
        IF new_grade IN ["A", "B", "C", "D", "F"]:
            grade = new_grade

    METHOD mark_attendance(present):
        IF present == true:
            attendance = attendance + 1
```

### 3. Query Methods

Methods that ask questions about the object's state and return boolean answers.

```pseudo
CLASS Email:
    PRIVATE is_read
    PRIVATE is_important
    PRIVATE has_attachment

    # Query methods - return true/false
    METHOD is_unread():
        RETURN NOT is_read

    METHOD requires_action():
        RETURN is_important OR has_attachment

    METHOD can_be_deleted():
        RETURN NOT is_important AND is_read
```

### 4. Action Methods

Methods that perform significant operations, often involving multiple steps.

```pseudo
CLASS CoffeeMachine:
    PRIVATE water_level
    PRIVATE coffee_beans
    PRIVATE is_on

    # Action method - complex operation
    METHOD make_coffee(coffee_type):
        IF NOT is_on:
            PRINT "Please turn on the machine first"
            RETURN

        IF water_level < 1:
            PRINT "Add water"
            RETURN

        IF coffee_beans < 10:
            PRINT "Add coffee beans"
            RETURN

        # Complex coffee-making process
        heat_water()
        grind_beans()
        brew_coffee(coffee_type)
        serve_coffee()

        # Update state
        water_level = water_level - 1
        coffee_beans = coffee_beans - 10

        PRINT coffee_type + " is ready!"
```

### 5. Factory Methods

Methods that create and return new objects.

```pseudo
CLASS ShoppingCart:
    PRIVATE items

    # Factory method - creates related objects
    METHOD create_order():
        order = NEW Order()
        order.items = COPY(items)
        order.total = calculate_total()
        order.status = "pending"
        RETURN order

    METHOD add_product(product_name, price):
        product = NEW Product()
        product.name = product_name
        product.price = price
        ADD product TO items
```

## Method Parameters and Return Values

### Parameters: Input to Methods

```pseudo
CLASS Calculator:
    METHOD add(a, b):
        RETURN a + b

    METHOD multiply(a, b):
        RETURN a * b

    # Multiple parameters
    METHOD calculate_discount(price, discount_percentage, is_member):
        discount = price * (discount_percentage / 100)
        IF is_member:
            discount = discount * 1.1  # Extra 10% for members
        RETURN price - discount
```

### Return Values: Output from Methods

```pseudo
CLASS WeatherStation:
    PRIVATE temperature
    PRIVATE humidity

    METHOD get_temperature_in_celsius():
        RETURN temperature

    METHOD get_temperature_in_fahrenheit():
        RETURN (temperature * 9/5) + 32

    METHOD get_weather_summary():
        IF temperature > 30:
            feeling = "hot"
        ELSE IF temperature < 10:
            feeling = "cold"
        ELSE:
            feeling = "pleasant"

        RETURN "It's " + feeling + " with " + humidity + "% humidity"

    # Can return different types
    METHOD get_all_metrics():
        RETURN {
            "temp_c": temperature,
            "temp_f": get_temperature_in_fahrenheit(),
            "humidity": humidity,
            "summary": get_weather_summary()
        }
```

## The `this` or `self` Reference

Inside methods, we often need to refer to the current object's attributes. Different languages use `this`, `self`, or implicit references.

```pseudo
# Explicit reference (like Java's 'this')
CLASS Student:
    PRIVATE name

    METHOD set_name(name):
        this.name = name  # 'this' refers to the current object
        # Distinguishes attribute 'name' from parameter 'name'

# Implicit reference (like Python's 'self')
CLASS Student:
    PRIVATE name

    METHOD set_name(name):
        self.name = name  # 'self' refers to the current object

# In our pseudo-code, we'll use implicit attribute access
CLASS Student:
    PRIVATE name

    METHOD set_name(new_name):
        name = new_name  # 'name' refers to the attribute
        # Since we're inside the class, it's clear
```

## Method Visibility: Public vs Private

Just like attributes, methods can be public (accessible from anywhere) or private (only accessible within the class).

```pseudo
CLASS UserAccount:
    PRIVATE password_hash
    PRIVATE failed_login_attempts

    # Public methods - interface to the world
    PUBLIC METHOD login(username, password):
        IF verify_password(password):
            failed_login_attempts = 0
            RETURN true
        ELSE:
            failed_login_attempts = failed_login_attempts + 1
            IF failed_login_attempts >= 3:
                lock_account()
            RETURN false

    PUBLIC METHOD change_password(old_password, new_password):
        IF verify_password(old_password):
            set_password(new_password)
            RETURN true
        RETURN false

    # Private methods - internal implementation details
    PRIVATE METHOD verify_password(input_password):
        RETURN hash(input_password) == password_hash

    PRIVATE METHOD set_password(new_password):
        password_hash = hash(new_password)

    PRIVATE METHOD lock_account():
        # Implementation details hidden
        # Send email, log event, etc.
```

## Practical Examples

### Example 1: Social Media Post

```pseudo
CLASS SocialMediaPost:
    PRIVATE content
    PRIVATE author
    PRIVATE likes_count
    PRIVATE comments: List
    PRIVATE timestamp

    # Constructor
    METHOD INITIALIZE(post_content, post_author):
        content = post_content
        author = post_author
        likes_count = 0
        comments = []
        timestamp = CURRENT_TIME()

    # Action methods
    METHOD like():
        likes_count = likes_count + 1
        PRINT author + "'s post got a like! Total: " + likes_count

    METHOD add_comment(comment_text, commenter):
        comment = {
            "text": comment_text,
            "author": commenter,
            "time": CURRENT_TIME()
        }
        ADD comment TO comments
        PRINT commenter + " commented: " + comment_text

    METHOD edit_content(new_content):
        old_content = content
        content = new_content
        PRINT "Post updated from: " + old_content + " to: " + new_content

    # Query methods
    METHOD get_likes_count():
        RETURN likes_count

    METHOD has_comments():
        RETURN LENGTH(comments) > 0

    METHOD is_popular():
        RETURN likes_count > 100 OR LENGTH(comments) > 20

    # Utility methods
    METHOD display_post():
        PRINT "Author: " + author
        PRINT "Time: " + timestamp
        PRINT "Content: " + content
        PRINT "Likes: " + likes_count
        PRINT "Comments: " + LENGTH(comments)
        PRINT "---"

    METHOD get_engagement_ratio():
        total_engagement = likes_count + LENGTH(comments)
        # Assuming content length as proxy for "effort"
        RETURN total_engagement / LENGTH(content)
```

### Example 2: Game Character with Combat Methods

```pseudo
CLASS GameCharacter:
    PRIVATE name
    PRIVATE health
    PRIVATE mana
    PRIVATE level
    PRIVATE inventory: Map  # item -> count
    PRIVATE equipped_weapon

    # Combat methods
    METHOD attack(target):
        IF health <= 0:
            PRINT name + " is defeated and cannot attack!"
            RETURN 0

        base_damage = 10 + (level * 2)

        # Weapon bonus
        IF equipped_weapon != null:
            base_damage = base_damage + equipped_weapon.damage

        # Critical hit chance
        IF RANDOM(1, 100) <= (level * 2):  # Higher level = more crit chance
            base_damage = base_damage * 1.5
            PRINT "Critical hit!"

        target.take_damage(base_damage)
        PRINT name + " attacks " + target.name + " for " + base_damage + " damage!"

        RETURN base_damage

    METHOD take_damage(amount):
        health = health - amount
        IF health <= 0:
            health = 0
            PRINT name + " has been defeated!"
        ELSE:
            PRINT name + " has " + health + " health remaining"

    METHOD heal(amount):
        max_health = 100 + (level * 20)
        old_health = health
        health = MIN(health + amount, max_health)
        healed = health - old_health
        PRINT name + " healed for " + healed + " health"
        RETURN healed

    # Inventory management methods
    METHOD use_item(item_name):
        IF inventory.CONTAINS_KEY(item_name) AND inventory[item_name] > 0:
            inventory[item_name] = inventory[item_name] - 1

            IF item_name == "health_potion":
                heal(50)
            ELSE IF item_name == "mana_potion":
                mana = MIN(mana + 30, 100 + (level * 10))
            ELSE IF item_name == "strength_potion":
                # Temporary buff - would need buff system
                PRINT name + " feels stronger!"

            PRINT "Used " + item_name
        ELSE:
            PRINT "Don't have " + item_name

    METHOD equip_weapon(weapon_name):
        IF inventory.CONTAINS_KEY(weapon_name) AND inventory[weapon_name] > 0:
            IF equipped_weapon != null:
                # Put old weapon back in inventory
                inventory[equipped_weapon.name] = inventory[equipped_weapon.name] + 1

            equipped_weapon = GET_WEapon_OBJECT(weapon_name)
            inventory[weapon_name] = inventory[weapon_name] - 1
            PRINT name + " equipped " + weapon_name
        ELSE:
            PRINT "Cannot find " + weapon_name

    # Utility methods
    METHOD get_status():
        RETURN {
            "name": name,
            "health": health + "/" + (100 + (level * 20)),
            "mana": mana + "/" + (50 + (level * 10)),
            "level": level,
            "weapon": IF equipped_weapon != null THEN equipped_weapon.name ELSE "None"
        }

    METHOD is_alive():
        RETURN health > 0
```

### Example 3: Online Shopping Cart

```pseudo
CLASS ShoppingCart:
    PRIVATE items: List  # List of {product, quantity, price}
    PRIVATE discount_code
    PRIVATE tax_rate
    PRIVATE is_checked_out

    # Constructor
    METHOD INITIALIZE():
        items = []
        discount_code = ""
        tax_rate = 0.08  # 8% tax
        is_checked_out = false

    # Core shopping methods
    METHOD add_item(product, quantity = 1):
        IF is_checked_out:
            PRINT "Cannot add items after checkout"
            RETURN

        # Check if product already in cart
        FOR item IN items:
            IF item.product.id == product.id:
                item.quantity = item.quantity + quantity
                PRINT "Updated " + product.name + " to " + item.quantity + " units"
                RETURN

        # Add new item
        new_item = {
            "product": product,
            "quantity": quantity,
            "price": product.price
        }
        ADD new_item TO items
        PRINT "Added " + quantity + " × " + product.name + " to cart"

    METHOD remove_item(product_id, quantity = 1):
        IF is_checked_out:
            PRINT "Cannot remove items after checkout"
            RETURN

        FOR item IN items:
            IF item.product.id == product_id:
                IF quantity >= item.quantity:
                    REMOVE item FROM items
                    PRINT "Removed " + item.product.name + " from cart"
                ELSE:
                    item.quantity = item.quantity - quantity
                    PRINT "Reduced " + item.product.name + " to " + item.quantity + " units"
                RETURN

        PRINT "Product not found in cart"

    METHOD update_quantity(product_id, new_quantity):
        IF new_quantity <= 0:
            remove_item(product_id)
        ELSE:
            FOR item IN items:
                IF item.product.id == product_id:
                    item.quantity = new_quantity
                    PRINT "Updated " + item.product.name + " to " + new_quantity + " units"
                    RETURN
            PRINT "Product not found in cart"

    # Calculation methods
    METHOD calculate_subtotal():
        subtotal = 0
        FOR item IN items:
            subtotal = subtotal + (item.price * item.quantity)
        RETURN subtotal

    METHOD calculate_tax():
        RETURN calculate_subtotal() * tax_rate

    METHOD calculate_discount():
        subtotal = calculate_subtotal()
        IF discount_code == "SAVE10":
            RETURN subtotal * 0.10
        ELSE IF discount_code == "SAVE20":
            RETURN subtotal * 0.20
        ELSE:
            RETURN 0

    METHOD calculate_total():
        subtotal = calculate_subtotal()
        tax = calculate_tax()
        discount = calculate_discount()
        RETURN subtotal + tax - discount

    # Checkout process methods
    METHOD apply_discount(code):
        VALID_CODES = ["SAVE10", "SAVE20", "WELCOME5"]
        IF code IN VALID_CODES:
            discount_code = code
            PRINT "Discount applied: " + code
        ELSE:
            PRINT "Invalid discount code"

    METHOD checkout(payment_method):
        IF is_checked_out:
            PRINT "Order already checked out"
            RETURN false

        IF LENGTH(items) == 0:
            PRINT "Cart is empty"
            RETURN false

        total = calculate_total()
        PRINT "=== CHECKOUT ==="
        PRINT "Items: " + LENGTH(items)
        PRINT "Subtotal: $" + calculate_subtotal()
        PRINT "Tax: $" + calculate_tax()
        PRINT "Discount: $" + calculate_discount()
        PRINT "Total: $" + total
        PRINT "Payment method: " + payment_method

        # Simulate payment processing
        IF process_payment(payment_method, total):
            is_checked_out = true
            PRINT "Payment successful! Order confirmed."
            generate_receipt()
            clear_cart_after_delay()  # Would clear after some time
            RETURN true
        ELSE:
            PRINT "Payment failed"
            RETURN false

    # Private helper methods
    PRIVATE METHOD process_payment(method, amount):
        # Simulate payment processing
        PRINT "Processing " + method + " payment of $" + amount
        # In real system, would contact payment gateway
        RETURN true  # Simulate success

    PRIVATE METHOD generate_receipt():
        receipt = "=== RECEIPT ===\n"
        receipt = receipt + "Date: " + CURRENT_DATE() + "\n"
        receipt = receipt + "Items:\n"

        FOR item IN items:
            receipt = receipt + "  " + item.product.name + " × " + item.quantity
            receipt = receipt + " @ $" + item.price + " = $" + (item.price * item.quantity) + "\n"

        receipt = receipt + "----------------\n"
        receipt = receipt + "Subtotal: $" + calculate_subtotal() + "\n"
        receipt = receipt + "Tax: $" + calculate_tax() + "\n"
        receipt = receipt + "Discount: $" + calculate_discount() + "\n"
        receipt = receipt + "TOTAL: $" + calculate_total() + "\n"

        PRINT receipt
        # In real system, would save to database and/or email to customer

    # Query methods
    METHOD get_item_count():
        total = 0
        FOR item IN items:
            total = total + item.quantity
        RETURN total

    METHOD is_empty():
        RETURN LENGTH(items) == 0

    METHOD contains_product(product_id):
        FOR item IN items:
            IF item.product.id == product_id:
                RETURN true
        RETURN false

    METHOD get_cart_summary():
        RETURN {
            "item_count": get_item_count(),
            "unique_items": LENGTH(items),
            "subtotal": calculate_subtotal(),
            "total": calculate_total(),
            "is_checked_out": is_checked_out
        }
```

## Method Overloading and Overriding

### Method Overloading (Same class, different parameters)

```pseudo
CLASS MathUtils:
    # Different versions of 'add' method
    METHOD add(a, b):
        RETURN a + b

    METHOD add(a, b, c):
        RETURN a + b + c

    METHOD add(numbers: List):
        total = 0
        FOR num IN numbers:
            total = total + num
        RETURN total
```

### Method Overriding (Different classes, same method signature)

```pseudo
CLASS Animal:
    METHOD make_sound():
        PRINT "Some generic animal sound"

CLASS Dog EXTENDS Animal:
    # Override parent method
    METHOD make_sound():
        PRINT "Woof! Woof!"

CLASS Cat EXTENDS Animal:
    # Override parent method
    METHOD make_sound():
        PRINT "Meow!"
```

## Best Practices for Methods

### 1. Single Responsibility Principle

Each method should do one thing well.

```pseudo
# BAD: Method does too much
METHOD process_user_data(data):
    validate(data)
    save_to_database(data)
    send_email(data)
    update_cache(data)
    log_activity(data)

# GOOD: Separate methods
METHOD validate_user_data(data)
METHOD save_user_data(data)
METHOD notify_user(data)
# etc.
```

### 2. Meaningful Names

```pseudo
# BAD
METHOD p()  # What does this do?
METHOD proc()  # Process what?
METHOD xyz()  # Cryptic!

# GOOD
METHOD calculate_tax()
METHOD validate_email()
METHOD send_notification()
```

### 3. Appropriate Length

Methods should generally be short (under 20-30 lines).

```pseudo
# BAD: Too long and complex
METHOD handle_customer_order():
    # 100 lines of code...

# GOOD: Break into smaller methods
METHOD create_order():
    validate_items()
    calculate_pricing()
    apply_discounts()
    generate_order_number()
```

### 4. Consistent Return Types

```pseudo
# BAD: Inconsistent returns
METHOD find_user(id):
    IF user_exists(id):
        RETURN user_object
    ELSE:
        RETURN false  # Mixed type return

# GOOD: Consistent returns
METHOD find_user(id):
    IF user_exists(id):
        RETURN user_object
    ELSE:
        RETURN null  # Always returns object or null
```

## Common Patterns

### 1. Builder Pattern Methods

```pseudo
CLASS EmailBuilder:
    PRIVATE to_address
    PRIVATE subject
    PRIVATE body
    PRIVATE attachments

    METHOD set_to(address):
        to_address = address
        RETURN self  # Allows method chaining

    METHOD set_subject(text):
        subject = text
        RETURN self

    METHOD set_body(text):
        body = text
        RETURN self

    METHOD add_attachment(file):
        ADD file TO attachments
        RETURN self

    METHOD build():
        RETURN NEW Email(to_address, subject, body, attachments)

# Usage with method chaining
email = NEW EmailBuilder()
    .set_to("friend@example.com")
    .set_subject("Hello!")
    .set_body("How are you?")
    .add_attachment("photo.jpg")
    .build()
```

### 2. Fluent Interface

```pseudo
CLASS QueryBuilder:
    METHOD select(columns):
        # ...
        RETURN self

    METHOD from_table(table):
        # ...
        RETURN self

    METHOD where(condition):
        # ...
        RETURN self

    METHOD execute():
        # ...
        RETURN results
```

## Practice Exercise: Library Management System

Create a `Library` class with methods for managing books and members:

1. **Required Methods:**

   - `add_book(title, author, isbn)`: Adds a new book to library
   - `register_member(name, member_id)`: Registers a new library member
   - `borrow_book(member_id, isbn)`: Allows member to borrow a book
   - `return_book(isbn)`: Processes book return
   - `search_books(keyword)`: Searches books by title or author
   - `get_overdue_books()`: Lists all overdue books

2. **Add Validation Methods:**

   - `can_borrow(member_id)`: Checks if member can borrow (no overdue, under limit)
   - `is_book_available(isbn)`: Checks if book is available

3. **Add Report Methods:**

   - `generate_library_report()`: Shows statistics
   - `get_member_activity(member_id)`: Shows member's borrowing history

4. **Bonus:** Implement `reserve_book(member_id, isbn)` method for reserving unavailable books.

```pseudo
CLASS Library:
    PRIVATE books: List
    PRIVATE members: List
    PRIVATE transactions: List

    METHOD INITIALIZE():
        books = []
        members = []
        transactions = []

    # Implement methods here...

    METHOD get_statistics():
        total_books = LENGTH(books)
        available_books = COUNT books WHERE book.is_available == true
        total_members = LENGTH(members)
        borrowed_books = total_books - available_books

        RETURN {
            "total_books": total_books,
            "available_books": available_books,
            "borrowed_books": borrowed_books,
            "total_members": total_members
        }
```

## Quick Check

1. **What's the difference between a getter and a setter method?**

   - Getter: Returns attribute value (read)
   - Setter: Modifies attribute value (write)

2. **Why should methods be relatively short?**

   - Easier to understand, test, and maintain
   - Follows Single Responsibility Principle

3. **What is method overloading?**

   - Having multiple methods with the same name but different parameters in the same class

4. **What is method overriding?**

   - Redefining a method in a child class that already exists in the parent class

---

**Next Chapter:** [Chapter 2.3: Constructors - The Birth of an Object](./chapter2-3.md) where we'll learn how objects are created and initialized!

> **Key Insight:** Methods bring objects to life. They transform passive data containers (attributes) into active, useful entities that can interact, change state, and solve problems. A well-designed set of methods makes an object intuitive and powerful to use.
