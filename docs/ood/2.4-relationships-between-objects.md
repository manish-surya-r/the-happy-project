# Chapter 2.4: Relationships Between Objects

## Introduction: No Object is an Island

Think about your relationships: you're a student in a class, you have friends, you live in a house, you use a smartphone. Objects in software are the same - they exist in networks of relationships. Understanding how objects connect is crucial for designing realistic, maintainable systems.

## The Three Fundamental Relationships

In Object-Oriented Design, objects have three main types of relationships:

| Relationship    | Symbol | Meaning                     | Real-World Example    |
| --------------- | ------ | --------------------------- | --------------------- |
| **Association** | `--`   | "Uses a" / "Knows about"    | Student -- Pen        |
| **Aggregation** | `◇--`  | "Has a" (weak ownership)    | Classroom ◇-- Student |
| **Composition** | `◆--`  | "Owns a" (strong ownership) | Car ◆-- Engine        |

## 1. Association: "Uses a" Relationship

**Association** is the simplest relationship - one object uses or interacts with another object, but doesn't own it.

### Characteristics:

- Objects are independent
- Both can exist without the other
- Usually temporary or situational
- Represents collaboration or usage

### Real-World Examples:

- A **student** uses a **library book** (but doesn't own it)
- A **teacher** teaches a **class** (but the class exists without that teacher)
- A **customer** places an **order** (customer exists without orders)

### Code Example: Student and Pen Association

```pseudo
CLASS Pen:
    PRIVATE ink_color
    PRIVATE ink_level

    METHOD write(text):
        IF ink_level > 0:
            PRINT "Writing in " + ink_color + ": " + text
            ink_level = ink_level - 1
        ELSE:
            PRINT "Out of ink!"

CLASS Student:
    PRIVATE name
    # No permanent reference to a pen

    METHOD take_exam(pen):
        # Student uses a pen temporarily
        pen.write("Answer to question 1: ...")
        pen.write("Answer to question 2: ...")
        # After exam, pen goes back to owner

# Usage
blue_pen = NEW Pen("blue", 100)
alex = NEW Student("Alex")

# Association happens here
alex.take_exam(blue_pen)  # Alex uses the pen

# After the method, objects are separate again
# Pen can be used by other students
```

### Types of Association:

#### a) One-to-One Association

```pseudo
CLASS Driver:
    PRIVATE license
    PRIVATE current_car  # One car at a time

    METHOD drive():
        IF current_car != null:
            current_car.start()
            current_car.accelerate()

CLASS Car:
    PRIVATE current_driver  # One driver at a time

# One driver <-> One car (at a time)
```

#### b) One-to-Many Association

```pseudo
CLASS Teacher:
    PRIVATE name
    PRIVATE classes_taught: List  # Many classes

    METHOD teach_all_classes():
        FOR class IN classes_taught:
            class.start_session()

CLASS Class:
    PRIVATE teacher  # One teacher
```

#### c) Many-to-Many Association

```pseudo
CLASS Student:
    PRIVATE courses: List  # Many courses

CLASS Course:
    PRIVATE students: List  # Many students

# Many students <-> Many courses
```

## 2. Aggregation: "Has a" Relationship (Weak Ownership)

**Aggregation** represents a whole-part relationship where the part can exist independently of the whole.

### Characteristics:

- "Has a" relationship
- Weak ownership - parts can belong to multiple wholes
- Parts can exist independently
- Usually represents collections or groups

### Real-World Examples:

- A **university** has **departments** (departments could exist independently)
- A **playlist** has **songs** (songs exist outside the playlist)
- A **shopping cart** has **items** (items exist without cart)

### Code Example: Classroom and Students Aggregation

```pseudo
CLASS Student:
    PRIVATE name
    PRIVATE student_id

    METHOD study(subject):
        PRINT name + " is studying " + subject

CLASS Classroom:
    PRIVATE room_number
    PRIVATE capacity
    PRIVATE students: List  # Aggregation - Classroom HAS Students

    METHOD INITIALIZE(room_num, cap):
        room_number = room_num
        capacity = cap
        students = []  # Starts empty

    METHOD add_student(student):
        IF LENGTH(students) < capacity:
            ADD student TO students
            PRINT student.name + " joined classroom " + room_number
        ELSE:
            PRINT "Classroom is full!"

    METHOD remove_student(student_id):
        FOR i FROM 0 TO LENGTH(students)-1:
            IF students[i].student_id == student_id:
                removed_student = students[i]
                REMOVE students[i]
                PRINT removed_student.name + " left the classroom"
                RETURN removed_student
        RETURN null

    METHOD conduct_class():
        PRINT "Class in room " + room_number + " is starting"
        FOR student IN students:
            student.study("Mathematics")

    METHOD get_class_size():
        RETURN LENGTH(students)

# Usage - Students exist independently
alex = NEW Student("Alex", "S001")
bella = NEW Student("Bella", "S002")
charlie = NEW Student("Charlie", "S003")

math_class = NEW Classroom("Room 101", 30)

# Aggregation: Classroom contains students
math_class.add_student(alex)
math_class.add_student(bella)

# Students can exist without the classroom
# Alex can study on his own
alex.study("Physics")

# Student can be in multiple classrooms
science_class = NEW Classroom("Lab 1", 20)
science_class.add_student(alex)  # Same student in different class

# Student can leave classroom but still exist
math_class.remove_student("S001")
# Alex still exists as a student object
```

### Key Insight:

In aggregation, destroying the whole doesn't destroy the parts:

```pseudo
# If classroom is destroyed...
DELETE math_class
# Students alex, bella, charlie still exist!
# They can join other classrooms
```

## 3. Composition: "Owns a" Relationship (Strong Ownership)

**Composition** is the strongest relationship - the whole owns the parts, and the parts cannot exist independently.

### Characteristics:

- "Owns a" relationship
- Strong ownership - parts belong to exactly one whole
- Parts cannot exist without the whole
- Lifecycle is tied together
- Usually represents physical or logical containment

### Real-World Examples:

- A **car** has an **engine** (engine doesn't exist without the car)
- A **human** has a **heart** (heart doesn't exist separately)
- A **house** has **rooms** (rooms are part of the house)

### Code Example: Computer and Components Composition

```pseudo
CLASS CPU:
    PRIVATE model
    PRIVATE speed

    METHOD process():
        PRINT model + " processing at " + speed + " GHz"

CLASS RAM:
    PRIVATE capacity
    PRIVATE speed

    METHOD store(data):
        PRINT "Storing " + data + " in " + capacity + " GB RAM"

CLASS Computer:
    PRIVATE brand
    PRIVATE cpu: CPU      # Composition - Computer OWNS CPU
    PRIVATE ram: RAM      # Composition - Computer OWNS RAM
    PRIVATE storage: List # Composition - Computer OWNS Storage

    METHOD INITIALIZE(computer_brand, cpu_model, cpu_speed, ram_capacity):
        brand = computer_brand

        # Composition: Creating parts inside the whole
        cpu = NEW CPU(cpu_model, cpu_speed)   # CPU created WITH computer
        ram = NEW RAM(ram_capacity, "3200MHz") # RAM created WITH computer
        storage = []

        PRINT brand + " computer created with " + cpu_model

    METHOD add_storage(storage_gb):
        new_drive = NEW Storage(storage_gb)  # Created as part of computer
        ADD new_drive TO storage

    METHOD power_on():
        PRINT brand + " computer starting up..."
        cpu.process()
        ram.store("OS Kernel")
        FOR drive IN storage:
            drive.initialize()
        PRINT "Computer ready!"

    METHOD get_specs():
        RETURN {
            "brand": brand,
            "cpu": cpu.model,
            "ram": ram.capacity + "GB",
            "storage_count": LENGTH(storage)
        }

    # When computer is destroyed, all components are destroyed
    METHOD destroy():
        PRINT "Destroying computer and all components..."
        # CPU, RAM, Storage are automatically destroyed
        # They cannot exist without the computer

# Usage
my_pc = NEW Computer("Dell", "Intel i7", 3.4, 16)
my_pc.add_storage(512)
my_pc.add_storage(1024)

my_pc.power_on()
# Output:
# "Dell computer starting up..."
# "Intel i7 processing at 3.4 GHz"
# "Storing OS Kernel in 16 GB RAM"

# The CPU and RAM cannot be accessed outside the computer
# They were created as part of the computer

# If we destroy the computer...
my_pc.destroy()
# The CPU, RAM, and Storage objects are also destroyed
# They cannot exist independently
```

### Composition vs Aggregation: The Critical Difference

| Aspect        | Composition                                | Aggregation                                |
| ------------- | ------------------------------------------ | ------------------------------------------ |
| **Ownership** | Strong - parts belong to exactly one whole | Weak - parts can belong to multiple wholes |
| **Lifetime**  | Same lifetime - parts die with whole       | Independent lifetimes                      |
| **Creation**  | Parts created with/inside the whole        | Parts created separately and added         |
| **Example**   | House -- Room                              | Classroom -- Student                       |
| **Code Sign** | `ClassA` creates `ClassB` inside itself    | `ClassA` receives `ClassB` as parameter    |

## Practical Examples Combining All Relationships

### Example 1: University System

```pseudo
# COMPOSITION: Strong ownership
CLASS Department:
    PRIVATE name
    PRIVATE head  # Composition: Department OWNS a Professor as head
    PRIVATE courses: List  # Composition: Department OWNS Courses

    METHOD INITIALIZE(dept_name, head_name):
        name = dept_name
        head = NEW Professor(head_name, "Head of " + dept_name)  # Created with department
        courses = []

    METHOD create_course(course_code, course_name):
        new_course = NEW Course(course_code, course_name, this)  # Created with department
        ADD new_course TO courses
        RETURN new_course

# COMPOSITION: Course owns its materials
CLASS Course:
    PRIVATE code
    PRIVATE name
    PRIVATE department  # Association: knows its department
    PRIVATE syllabus  # Composition: Course OWNS Syllabus
    PRIVATE assignments: List  # Composition: Course OWNS Assignments

    METHOD INITIALIZE(course_code, course_name, course_dept):
        code = course_code
        name = course_name
        department = course_dept  # Association, not composition
        syllabus = NEW Syllabus()  # Created with course
        assignments = []

# AGGREGATION: University has departments
CLASS University:
    PRIVATE name
    PRIVATE departments: List  # Aggregation: University HAS Departments

    METHOD INITIALIZE(univ_name):
        name = univ_name
        departments = []

    METHOD add_department(department):
        ADD department TO departments  # Department exists independently

    METHOD get_all_courses():
        all_courses = []
        FOR dept IN departments:
            ADD_ALL dept.courses TO all_courses
        RETURN all_courses

# ASSOCIATION: Professor teaches Courses
CLASS Professor:
    PRIVATE name
    PRIVATE title
    PRIVATE teaching_courses: List  # Association: teaches courses

    METHOD INITIALIZE(prof_name, prof_title):
        name = prof_name
        title = prof_title
        teaching_courses = []

    METHOD teach(course):
        ADD course TO teaching_courses  # Association
        PRINT name + " is teaching " + course.name

    METHOD stop_teaching(course):
        REMOVE course FROM teaching_courses
        # Course continues to exist without professor

# AGGREGATION: Student enrolled in Courses
CLASS Student:
    PRIVATE name
    PRIVATE student_id
    PRIVATE enrolled_courses: List  # Aggregation: Student HAS Courses

    METHOD INITIALIZE(student_name, id):
        name = student_name
        student_id = id
        enrolled_courses = []

    METHOD enroll(course):
        ADD course TO enrolled_courses  # Course exists independently
        PRINT name + " enrolled in " + course.name

    METHOD drop_course(course):
        REMOVE course FROM enrolled_courses
        # Course continues without this student

# Usage
mit = NEW University("MIT")

cs_dept = NEW Department("Computer Science", "Dr. Smith")
mit.add_department(cs_dept)  # Aggregation

cs101 = cs_dept.create_course("CS101", "Intro to Programming")  # Composition

prof_jones = NEW Professor("Dr. Jones", "Associate Professor")
prof_jones.teach(cs101)  # Association

alex = NEW Student("Alex", "S001")
alex.enroll(cs101)  # Aggregation

# Relationships summary:
# - University ◇-- Department (Aggregation)
# - Department ◆-- Course (Composition)
# - Department ◆-- Professor as head (Composition)
# - Professor -- Course (Association)
# - Student ◇-- Course (Aggregation)
```

### Example 2: E-commerce System

```pseudo
# COMPOSITION: Order owns OrderItems
CLASS Order:
    PRIVATE order_id
    PRIVATE customer  # Association: knows customer
    PRIVATE items: List  # Composition: Order OWNS OrderItems
    PRIVATE shipping_address  # Composition: Order OWNS Address
    PRIVATE status

    METHOD INITIALIZE(id, cust, address):
        order_id = id
        customer = cust  # Association
        shipping_address = NEW Address(address)  # Composition
        items = []
        status = "pending"

    METHOD add_product(product, quantity):
        # Composition: OrderItem created as part of Order
        item = NEW OrderItem(product, quantity, this)
        ADD item TO items
        PRINT "Added " + quantity + " × " + product.name

    METHOD calculate_total():
        total = 0
        FOR item IN items:
            total = total + item.get_subtotal()
        RETURN total

    METHOD ship():
        status = "shipped"
        PRINT "Order " + order_id + " shipped to " + shipping_address.format()
        # OrderItems are shipped with the order (composition)

# COMPOSITION: OrderItem is part of Order
CLASS OrderItem:
    PRIVATE product  # Association: knows product
    PRIVATE quantity
    PRIVATE order  # Association: knows parent order

    METHOD INITIALIZE(prod, qty, parent_order):
        product = prod  # Association
        quantity = qty
        order = parent_order  # Association

    METHOD get_subtotal():
        RETURN product.price * quantity

# AGGREGATION: ShoppingCart has Products
CLASS ShoppingCart:
    PRIVATE customer  # Association
    PRIVATE items: Map  # Aggregation: Cart HAS Products

    METHOD INITIALIZE(cust):
        customer = cust
        items = {}  # product_id -> quantity

    METHOD add_item(product, qty = 1):
        IF items.CONTAINS_KEY(product.id):
            items[product.id] = items[product.id] + qty
        ELSE:
            items[product.id] = qty
        # Product exists independently of cart

    METHOD remove_item(product_id):
        REMOVE product_id FROM items
        # Product continues to exist

    METHOD checkout():
        order = NEW Order(GENERATE_ID(), customer, customer.get_address())
        FOR product_id, quantity IN items:
            product = GET_PRODUCT(product_id)  # Product exists independently
            order.add_product(product, quantity)
        items = {}  # Clear cart, products unaffected
        RETURN order

# ASSOCIATION: Customer uses PaymentMethod
CLASS Customer:
    PRIVATE name
    PRIVATE email
    PRIVATE default_payment  # Association: uses payment method

    METHOD set_payment_method(payment):
        default_payment = payment  # Association
        PRINT name + " set payment method to " + payment.type

    METHOD make_purchase(amount):
        IF default_payment != null:
            RETURN default_payment.process(amount)  # Association
        ELSE:
            ERROR "No payment method set"

# Usage
customer = NEW Customer("Alice", "alice@example.com")

credit_card = NEW CreditCard("1234-5678-9012-3456", "12/25")
customer.set_payment_method(credit_card)  # Association

cart = NEW ShoppingCart(customer)

product1 = NEW Product("P001", "Laptop", 999.99)  # Product exists independently
product2 = NEW Product("P002", "Mouse", 29.99)

cart.add_item(product1, 1)  # Aggregation
cart.add_item(product2, 2)  # Aggregation

order = cart.checkout()  # Creates order with composition
# Order owns OrderItems, which reference Products (association)
```

## Relationship Strength Hierarchy

```
Strongest
    |
    |-- COMPOSITION (Owns a, parts die with whole)
    |
    |-- AGGREGATION (Has a, independent parts)
    |
    |-- ASSOCIATION (Uses a, temporary relationship)
    |
Weakest
```

## UML Diagram Notation

```pseudo
# Text representation of UML relationships:

# Association (simple line)
Student ----- Pen

# Aggregation (empty diamond)
Classroom ◇----- Student

# Composition (filled diamond)
Car ◆----- Engine

# Multiplicity indicators:
#   1           - One
#   * or 0..*   - Zero or more
#   1..*        - One or more
#   0..1        - Zero or one
#   2..4        - Between 2 and 4

# Examples with multiplicity:
University "1" ◇----- "*" Department
Department "1" ◆----- "*" Course
Student "*" ----- "*" Course
Driver "1" ----- "1" Car (at a time)
```

## Design Guidelines: Which Relationship to Use?

### Ask These Questions:

1. **"Does the part exist independently of the whole?"**

   - Yes → **Association** or **Aggregation**
   - No → **Composition**

2. **"Can the part belong to multiple wholes?"**

   - Yes → **Aggregation**
   - No → **Composition**

3. **"Is the relationship permanent?"**

   - Yes → **Composition** or **Aggregation**
   - No → **Association**

### Decision Flowchart:

```
Start: Two classes A and B
     ↓
Does A create/destroy B?
     ↓
Yes → COMPOSITION (A owns B)
     ↓
No → Can B exist without A?
     ↓
No → Actually, reconsider - might be composition!
     ↓
Yes → Is B part of A's structure?
     ↓
Yes → AGGREGATION (A has B)
     ↓
No → ASSOCIATION (A uses B)
```

## Common Patterns and Examples

### Pattern 1: Tree Structure (Composition)

```pseudo
CLASS FileSystemItem:
    PRIVATE name

    # Methods for all items

CLASS Folder EXTENDS FileSystemItem:
    PRIVATE children: List  # Composition: Folder OWNS children

    METHOD add_child(item):
        ADD item TO children  # Item created as part of folder

    METHOD delete():
        # Delete all children first (composition)
        FOR child IN children:
            child.delete()
        # Then delete self

CLASS File EXTENDS FileSystemItem:
    PRIVATE content
    # No children - leaf node
```

### Pattern 2: Observer Pattern (Association)

```pseudo
CLASS Subject:
    PRIVATE observers: List  # Association: knows observers

    METHOD attach(observer):
        ADD observer TO observers  # Observer exists independently

    METHOD notify_all():
        FOR observer IN observers:
            observer.update(this)

CLASS Observer:
    METHOD update(subject):
        # React to subject changes
        # Association: uses subject
```

### Pattern 3: Composite Pattern (Mix of Composition and Aggregation)

```pseudo
CLASS Graphic:
    # Base class

CLASS Circle EXTENDS Graphic:
    PRIVATE radius
    # Leaf - no children

CLASS GraphicGroup EXTENDS Graphic:
    PRIVATE graphics: List  # Can contain both leaves and groups

    METHOD add(graphic):
        ADD graphic TO graphics  # Graphic exists independently

    METHOD draw():
        FOR graphic IN graphics:
            graphic.draw()  # Delegation
```

## Advanced Relationships

### 1. Dependency

Even weaker than association - one class depends on another (often as method parameter or return type).

```pseudo
CLASS ReportGenerator:
    # Dependency on DataFetcher (only in method signature)
    METHOD generate_report(fetcher: DataFetcher):
        data = fetcher.fetch_data()  # Temporary dependency
        # Process and return report
```

### 2. Realization/Implementation

A class implements an interface.

```pseudo
INTERFACE Flyable:
    METHOD fly()

CLASS Bird IMPLEMENTS Flyable:  # Realization
    METHOD fly():
        PRINT "Flapping wings"

CLASS Airplane IMPLEMENTS Flyable:  # Realization
    METHOD fly():
        PRINT "Using jet engines"
```

## Practice Exercise: Social Media Platform

Design the object relationships for a social media platform:

1. **Identify relationships between:**

   - User, Profile, Post, Comment, Friend, Group, Message

2. **For each pair, determine if it's:**

   - Composition (◆), Aggregation (◇), or Association (--)

3. **Consider:**

   - Does a post exist without a user?
   - Can a comment exist without a post?
   - Is a profile part of a user?
   - Can users share friends?
   - Do groups own their members?

4. **Write pseudo-code showing key relationships:**

```pseudo
CLASS User:
    PRIVATE profile  # What relationship?
    PRIVATE posts: List  # What relationship?
    PRIVATE friends: List  # What relationship?
    PRIVATE groups: List  # What relationship?

CLASS Post:
    PRIVATE author  # What relationship?
    PRIVATE comments: List  # What relationship?

CLASS Comment:
    PRIVATE author  # What relationship?
    PRIVATE post  # What relationship?

CLASS Group:
    PRIVATE members: List  # What relationship?
    PRIVATE admin  # What relationship?
```

## Common Mistakes to Avoid

### 1. Confusing Aggregation with Composition

```pseudo
# WRONG: Using composition for independent parts
CLASS Playlist:
    PRIVATE songs: List  # BAD if songs created inside playlist

    METHOD INITIALIZE():
        songs = []
        songs.ADD(NEW Song("Song1"))  # WRONG - songs can't exist independently!
        songs.ADD(NEW Song("Song2"))

# CORRECT: Using aggregation for independent parts
CLASS Playlist:
    PRIVATE songs: List

    METHOD add_song(song):  # Song created elsewhere
        ADD song TO songs  # Song exists independently
```

### 2. Creating Circular Dependencies

```pseudo
# PROBLEM: Circular reference
CLASS A:
    PRIVATE b: B

    METHOD set_b(b_obj):
        b = b_obj
        b.set_a(this)  # Creates circular reference

CLASS B:
    PRIVATE a: A

    METHOD set_a(a_obj):
        a = a_obj
        a.set_b(this)  # Infinite loop!

# SOLUTION: Use weak references or break the cycle
```

### 3. Overusing Composition

```pseudo
# TOO RIGID: Everything is composition
CLASS House:
    PRIVATE rooms: List  # Composition - OK
    PRIVATE address  # Composition - OK
    PRIVATE owner  # Composition - WRONG! Owner exists independently!

# BETTER: Mix of relationships
CLASS House:
    PRIVATE rooms: List  # Composition
    PRIVATE address  # Composition
    PRIVATE owner  # Association (reference to Owner object)
```

## Quick Check

1. **What's the key difference between aggregation and composition?**

   - In aggregation, parts can exist independently; in composition, they cannot.

2. **Which relationship would you use for:**

   - A Student and their School ID card? → **Composition** (card doesn't exist without student)
   - A Teacher and their Students? → **Aggregation** (students exist without teacher)
   - A Customer and a Shopping Cart? → **Association** (temporary usage)

3. **True or False: In composition, destroying the whole also destroys the parts.**

   - True

4. **What does multiplicity "1..\*" mean?**

   - One or more (at least one)

5. **Which is stronger: association or aggregation?**

   - Aggregation is stronger (more tightly coupled)

---

**Next Chapter:** [Part 3: Designing Robust Systems](./part3/chapter3-1.md) where we'll learn about interfaces, abstract classes, and design principles!

> **Key Insight:** Relationships give software its structure. Just like social relationships define human society, object relationships define how software systems are organized. Choosing the right relationship type is crucial for creating flexible, maintainable, and intuitive designs. Remember: composition for inseparable parts, aggregation for collections, and association for temporary collaborations.
